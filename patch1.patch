--- hpcbmtenv.sh	2021-05-08 09:50:29.460000000 +0900
+++ /home/hirtanak/workplace.lnk/github/hpccicd/01/hpcbmtenv-command.sh	2021-05-08 17:14:31.503034900 +0900
@@ -6,10 +6,10 @@ SCRIPTVERSION=0.3.1
 echo "SCRIPTVERSION: $SCRIPTVERSION - startup azure hpc delopment create script..."
 
 ### 基本設定
-MyResourceGroup=tmcbmt01
+MyResourceGroup=tmcbmt01-hpccicd01
 Location=japaneast #southcentralus
-VMPREFIX=tmcbmt01
-VMSIZE=Standard_HB120rs_v2 #Standard_D2as_v4 #Standard_HC44rs, Standard_HB120rs_v3
+VMPREFIX=hpccicd01
+VMSIZE=Standard_HB120rs_v2 #Standard_HC44rs, Standard_HB120rs_v3
 PBSVMSIZE=Standard_D8as_v4
 MAXVM=2 # 作成するコンピュートノード数
 
@@ -37,10 +37,10 @@ PBSPERMANENTDISK=2048
 # サブスクリプションが複数ある場合は指定しておく
 #az account set -s <Subscription ID or name>
 # サービスプリンシパルの利用も可能以下のパラメータとログイン処理(az login)を有効にすること
-#azure_name="uuid"
-#azure_password="uuid"
-#azure_tenant="uuid"
-#az login --service-principal --username ${azure_name} --password ${azure_password} --tenant ${azure_tenant} --output none
+azure_name="http://hirostCycleCloudApp20190203"
+azure_password="ff79a450-451f-48fc-9404-60aed156b854"
+azure_tenant="72f988bf-86f1-41af-91ab-2d7cd011db47"
+az login --service-principal --username ${azure_name} --password ${azure_password} --tenant ${azure_tenant} --output none
 
 # デバックオプション: DEBUG="parallel -v"
 # コマンド名取得
@@ -135,57 +135,55 @@ function getipaddresslist () {
 		fi
 	done
 	# pbs, loging, cyclecloud など削除
-	grep "tmcbmt01-[1-99]" ./tmpfile > ./tmpfile2
+	grep "${VMPREFIX}-[1-99]" ./tmpfile > ./tmpfile2
 	# 自然番号順にソート
 	sort -V ./tmpfile2 > tmpfile3
+	echo "az vm list-ip-addresses..."
+	cat ./tmpfile3
 
-    if [ $# -gt 4 ]; then
-    	echo "引数の数が間違っています！"
-    	exit 1
-	fi
+	# Check num of parameters.
+    if [ $# -gt 4 ]; then echo "error!. you can use 3 parameters."; exit 1; fi
 
-    if [ $# -ge 1 ]; then
+	if [ "$1" = "vmlist" ]; then
 		# vmlist 作成: $1
 		echo "creating vmlist"
-		cut -f $1 ./tmpfile3 > vmlist
+		cut -f 1 ./tmpfile3 > vmlist
 		# vmlist チェック
 		numvm=$(cat ./vmlist | wc -l)
-		if [ $((numip)) -eq $((MAXVM)) ]; then
-			echo "number of ipaddresslist and maxmv are matched."
+		if [ $((numvm)) -eq $((MAXVM)) ]; then
+			echo "number of vmlist and maxvm are matched."
 		else
-			echo "unmatched!"
+			echo "number of vmlist and maxvm are unmatched!"
 		fi
 	fi
 
-    if [ $# -ge 2 ]; then
+	if [ "$2" = "ipaddresslist" ]; then
 		# ipaddresslist 作成: $2
 		echo "careating IP Address list"
-		cut -f $2 ./tmpfile3 > ipaddresslist
+		cut -f 2 ./tmpfile3 > ipaddresslist
 		echo "ipaddresslist file contents"
 		cat ./ipaddresslist
-		# az vm list-ip-addresses --query を利用する場合、必要がない: sed -i -e '/^$/d' ./ipaddresslist
 		numip=$(cat ./ipaddresslist | wc -l)
 		# ipaddresslist チェック
 		if [ $((numip)) -eq $((MAXVM)) ]; then
 			echo "number of ipaddresslist and maxvm are matched."
 		else
-			echo "unmatched!"
+			echo "number of ipaddresslist and maxvm are unmatched!"
 		fi
 	fi
 
-    if [ $# -ge 3 ]; then
+	if [ $# -eq 3 ] && [ "$3" = "nodelist" ]; then
 		# nodelist 作成: $3
 		echo "careating nodelist"
-		cut -f $3 ./tmpfile3 > nodelist
+		cut -f 3 ./tmpfile3 > nodelist
 		echo "nodelist file contents"
 		cat ./nodelist
-		# az vm list-ip-addresses --query を利用する場合、必要がない: sed -i -e '/^$/d' ./ipaddresslist
-		numip=$(cat ./nodelist | wc -l)
+		numnd=$(cat ./nodelist | wc -l)
 		# nodelist チェック
-		if [ $((numip)) -eq $((MAXVM)) ]; then
+		if [ $((numnd)) -eq $((MAXVM)) ]; then
 			echo "number of nodelist and maxvm are matched."
 		else
-			echo "unmatched!"
+			echo "number of nodelist and maxvm are unmatched!"
 		fi
 	fi
 
@@ -195,6 +193,221 @@ function getipaddresslist () {
 	rm ./tmpfile3
 }
 
+function mountdirectory () {
+	# $1: vm:  vm1 or pbs
+	# $2: directory: /mnt/resource/scrach or /mnt/share
+	# requirement, ipaddresslist
+	# case1: vm1, /mnt/resource/scratch, case2: pbs /mnt/share
+	directory="$2"
+	if [ "$1" = vm1 ] && [ -z "$2" ]; then
+		directory="/mnt/resource/scratch"
+	fi
+	if [ "$1" = pbs ] && [ -z "$2" ]; then
+		directory="/mnt/share"
+	fi
+	echo "directory: $directory"
+	if [ ! -f ./ipaddresslist ]; then echo "error!. ./ipaddresslist is not found!"; fi 
+	case $1 in 
+		vm1 )
+			# コマンド実行判断
+			vm1ip=$(az vm show -d -g $MyResourceGroup --name ${VMPREFIX}-1 --query publicIps -o tsv)
+			echo "${VMPREFIX}-1's IP: $vm1ip"
+			# コンピュートノードVM#1：マウント用プライベートIP 
+			mountip=$(az vm show -g $MyResourceGroup --name ${VMPREFIX}-1 -d --query privateIps -otsv)
+			echo "checking ssh access for vm1..."
+			for count in $(seq 1 10); do
+				checkssh=(ssh -o StrictHostKeyChecking=no -i "${SSHKEYDIR}" -t "$USERNAME"@"${vm1ip}" "uname")
+				if [ -n "$checkssh" ]; then
+					break
+				else
+					checkssh=(ssh -o StrictHostKeyChecking=no -i "${SSHKEYDIR}" -t "$USERNAME"@"${vm1ip}" "uname")
+					echo "getting ssh connection. sleep 2" && sleep 2
+				fi	
+			done
+			if [ -n "$checkssh" ]; then
+				echo "${VMPREFIX}-1: $vm1ip - mount setting by ssh"
+				ssh -o StrictHostKeyChecking=no -i "${SSHKEYDIR}" -t -t $USERNAME@"${vm1ip}" "sudo mkdir -p ${directory}"
+				ssh -o StrictHostKeyChecking=no -i "${SSHKEYDIR}" -t -t $USERNAME@"${vm1ip}" "sudo chown $USERNAME:$USERNAME ${directory}"
+				ssh -o StrictHostKeyChecking=no -i "${SSHKEYDIR}" -t -t $USERNAME@"${vm1ip}" "sudo systemctl start rpcbind && sudo systemctl start nfs-server"
+				ssh -o StrictHostKeyChecking=no -i "${SSHKEYDIR}" -t -t $USERNAME@"${vm1ip}" 'sudo showmount -e'
+				# 1行目を削除したIPアドレスリストを作成
+				sed '1d' ./ipaddresslist > ./ipaddresslist-tmp
+				echo "${VMPREFIX}-2 to $MAXVM: mounting"
+				parallel -a ipaddresslist-tmp "ssh -o StrictHostKeyChecking=no -i ${SSHKEYDIR} -t -t $USERNAME@{} "sudo mkdir -p ${directory}""
+				parallel -a ipaddresslist-tmp "ssh -o StrictHostKeyChecking=no -i ${SSHKEYDIR} -t -t $USERNAME@{} "sudo chown $USERNAME:$USERNAME ${directory}""
+				parallel -a ipaddresslist-tmp "ssh -o StrictHostKeyChecking=no -i ${SSHKEYDIR} -t -t $USERNAME@{} "sudo mount -t nfs ${mountip}:${directory} ${directory}""
+				echo "current mounting status"
+				parallel -a ipaddresslist-tmp "ssh -o StrictHostKeyChecking=no -i ${SSHKEYDIR} -t -t $USERNAME@{} "df -h | grep ${directory}""
+				rm ./ipaddresslist-tmp
+			else
+				echo "vm1: mount setting by az vm run-command"
+				for count in $(seq 2 $MAXVM) ; do
+					az vm run-command invoke -g $MyResourceGroup --name ${VMPREFIX}-"${count}" --command-id RunShellScript --scripts "sudo mount -t nfs ${mountip}:${directory} ${directory}" 
+					echo "sleep 60" && sleep 60
+				done
+			fi
+		;;
+		pbs )
+			# PBSノード：展開済みかチェック: pbsvmname=$(az vm show -d -g $MyResourceGroup --name ${VMPREFIX}-pbs --query name -o tsv)
+			pbsvmip=$(az vm show -d -g $MyResourceGroup --name ${VMPREFIX}-pbs --query publicIps -o tsv)
+			# PBSノード：マウントプライベートIP
+			pbsmountip=$(az vm show -g $MyResourceGroup --name ${VMPREFIX}-pbs -d --query privateIps -otsv)
+			echo "checking ssh access for pbs..."
+			for count in $(seq 1 10); do
+				checkssh=(ssh -o StrictHostKeyChecking=no -i "${SSHKEYDIR}" -t "$USERNAME"@"${pbsvmip}" "uname")
+				if [ -n "$checkssh" ]; then
+					break
+				else
+					checkssh=$(ssh -o StrictHostKeyChecking=no -i "${SSHKEYDIR}" -t "$USERNAME"@"${pbsvmip}" "uname")
+					echo "getting ssh connection. sleep 2" && sleep 2
+				fi	
+			done
+			if [ -n "$checkssh" ]; then
+				echo "pbsnode: mount setting by ssh"
+				parallel -a ipaddresslist "ssh -o StrictHostKeyChecking=no -i ${SSHKEYDIR} -t -t $USERNAME@{} "sudo mkdir -p ${directory}""
+				parallel -a ipaddresslist "ssh -o StrictHostKeyChecking=no -i ${SSHKEYDIR} -t -t $USERNAME@{} "sudo chown $USERNAME:$USERNAME ${directory}""
+				parallel -a ipaddresslist "ssh -o StrictHostKeyChecking=no -i ${SSHKEYDIR} -t -t $USERNAME@{} "sudo mount -t nfs ${pbsmountip}:${directory} ${directory}""
+				echo "current mounting status"
+				parallel -a ipaddresslist "ssh -o StrictHostKeyChecking=no -i ${SSHKEYDIR} -t -t $USERNAME@{} "df -h | grep ${directory}""
+			else
+				echo "pbsnode: mount setting by az vm run-command"
+				for count in $(seq 1 $MAXVM) ; do
+					az vm run-command invoke -g $MyResourceGroup --name ${VMPREFIX}-"${count}" --command-id RunShellScript --scripts "sudo mount -t nfs ${pbsmountip}:${directory} ${directory}"
+					echo "sleep 60" && sleep 60
+				done
+			fi
+		;;
+	esac
+}
+
+function checksshconnection () {
+	# $1: vm1, pbs, all
+	# requirement, ipaddresslist
+	# usecase: connected - Linux or, disconnected - nothing
+	case $1 in
+		vm1 )
+			vm1ip=$(az vm show -d -g $MyResourceGroup --name ${VMPREFIX}-1 --query publicIps -o tsv)
+			for cnt in $(seq 1 10); do
+				checkssh=$(ssh -o StrictHostKeyChecking=no -i "${SSHKEYDIR}" -t $USERNAME@"${vm1ip}" "uname")
+				if [ -n "$checkssh" ]; then
+					break
+				fi
+				echo "waiting sshd @ ${VMPREFIX}-${vm1ip}: sleep 5" && sleep 5
+			done
+		;;
+		pbs )
+			pbsvmip=$(az vm show -d -g $MyResourceGroup --name ${VMPREFIX}-pbs --query publicIps -o tsv)
+			for cnt in $(seq 1 10); do
+				checkssh=$(ssh -o StrictHostKeyChecking=no -i "${SSHKEYDIR}" -t $USERNAME@"${pbsvmip}" "uname")
+				if [ -n "$checkssh" ]; then
+					break
+				fi
+				echo "waiting sshd @ ${VMPREFIX}-${vm1ip}: sleep 5" && sleep 5
+			done
+		;;
+		all )
+			if [ -f ./checksshtmp ]; then rm ./checksshtmp; fi
+			for count in $(seq 1 $MAXVM); do
+				line=$(sed -n "${count}"P ./ipaddresslist)
+				for cnt in $(seq 1 10); do
+					checksshtmp=$(ssh -o StrictHostKeyChecking=no -i "${SSHKEYDIR}" -t $USERNAME@"${line}" "uname")
+					if [ -n "${checksshtmp}" ]; then
+						echo "${checksshtmp}" >> checksshtmp
+						break
+					fi
+					echo "waiting ssh connection @ ${VMPREFIX}-${count}: sleep 5" && sleep 5
+				done
+			done
+		;;
+	esac
+}
+
+function settingpasswordless () {
+	# 作成中。。。
+	# $1: vm1, pbs, all, 2-n, login
+	# requirement, ipaddresslist
+	# locale, sudo, passwordless, ssh config
+	case $1 in
+		vm1 )
+			echo "vm1: all basic settings...."
+			vm1ip=$(az vm show -d -g $MyResourceGroup --name ${VMPREFIX}-1 --query publicIps -o tsv)
+			# SSHローケール設定変更
+			echo "configuring /etc/ssh/config locale setting"
+			locale=$(ssh -o StrictHostKeyChecking=no -i "${SSHKEYDIR}" $USERNAME@"${vm1ip}" -t -t "grep 'LC_ALL=C' /home/$USERNAME/.bashrc")
+			if [ -z "$locale" ]; then
+				ssh -o StrictHostKeyChecking=no -i "${SSHKEYDIR}" $USERNAME@"${vm1ip}" -t -t "echo "export 'LC_ALL=C'" >> /home/$USERNAME/.bashrc"
+			else
+				echo "LC_ALL=C has arelady setting"
+			fi
+		;;
+		pbs )
+			echo "pbs: all basic settings...."
+			pbsvmip=$(az vm show -d -g $MyResourceGroup --name ${VMPREFIX}-pbs --query publicIps -o tsv)
+			# SSHローケール設定変更
+			echo "configuring /etc/ssh/config locale setting"
+			locale=$(ssh -o StrictHostKeyChecking=no -i "${SSHKEYDIR}" $USERNAME@"${pbsvmip}" -t -t "grep 'LC_ALL=C' /home/$USERNAME/.bashrc")
+			if [ -z "$locale" ]; then
+				ssh -o StrictHostKeyChecking=no -i "${SSHKEYDIR}" $USERNAME@"${pbsvmip}" -t -t "echo "export 'LC_ALL=C'" >> /home/$USERNAME/.bashrc"
+			else
+				echo "LC_ALL=C has arelady setting"
+			fi
+			# PBSノード：sudo設定
+			echo "PBSノード: sudo 設定"
+			ssh -o StrictHostKeyChecking=no -i "${SSHKEYDIR}" $USERNAME@"${pbsvmip}" -t -t "sudo cat /etc/sudoers | grep $USERNAME" > sudotmp
+			sudotmp=$(cat ./sudotmp)
+			if [ -z "$sudotmp" ]; then
+				ssh -o StrictHostKeyChecking=no -i "${SSHKEYDIR}" $USERNAME@"${pbsvmip}" -t -t "echo "$USERNAME ALL=NOPASSWD: ALL" | sudo tee -a /etc/sudoers"
+			fi
+			unset sudotmp && rm ./sudotmp
+			# PBSノード：パスワードレス設定
+			echo "PBSノード: confugring passwordless settings"
+			scp -o StrictHostKeyChecking=no -i "${SSHKEYDIR}" ./${VMPREFIX} $USERNAME@"${pbsvmip}":/home/$USERNAME/.ssh/${VMPREFIX}
+			scp -o StrictHostKeyChecking=no -i "${SSHKEYDIR}" ./${VMPREFIX} $USERNAME@"${pbsvmip}":/home/$USERNAME/.ssh/id_rsa
+			ssh -o StrictHostKeyChecking=no -i "${SSHKEYDIR}" $USERNAME@"${pbsvmip}" -t -t "chmod 600 /home/$USERNAME/.ssh/id_rsa"
+			scp -o StrictHostKeyChecking=no -i "${SSHKEYDIR}" ./${VMPREFIX}.pub $USERNAME@"${pbsvmip}":/home/$USERNAME/.ssh/${VMPREFIX}.pub
+			# SSH Config設定
+			scp -o StrictHostKeyChecking=no -i "${SSHKEYDIR}" ./config $USERNAME@"${pbsvmip}":/home/$USERNAME/.ssh/config
+			ssh -o StrictHostKeyChecking=no -i "${SSHKEYDIR}" $USERNAME@"${pbsvmip}" -t -t "chmod 600 /home/$USERNAME/.ssh/config"
+		;;
+		all )
+			# SSHローケール設定変更
+			echo "configuring /etc/ssh/config locale setting"
+			for count in $(seq 1 $MAXVM); do
+				line=$(sed -n "${count}"P ./ipaddresslist)
+				locale=$(ssh -o StrictHostKeyChecking=no -i "${SSHKEYDIR}" $USERNAME@"${line}" -t -t "grep 'LC_ALL=C' /home/$USERNAME/.bashrc")
+				if [ -z "$locale" ]; then
+					ssh -o StrictHostKeyChecking=no -i "${SSHKEYDIR}" $USERNAME@"${line}" -t -t "echo "export 'LC_ALL=C'" >> /home/$USERNAME/.bashrc"
+				else
+					echo "LC_ALL=C has arelady setting"
+				fi
+			done
+		;;
+		2-n )
+		# SSHローケール設定変更
+		echo "configuring /etc/ssh/config locale setting"
+		for count in $(seq 1 $MAXVM); do
+			line=$(sed -n "${count}"P ./ipaddresslist)
+			locale=$(ssh -o StrictHostKeyChecking=no -i "${SSHKEYDIR}" $USERNAME@"${line}" -t -t "grep 'LC_ALL=C' /home/$USERNAME/.bashrc")
+			if [ -z "$locale" ]; then
+				ssh -o StrictHostKeyChecking=no -i "${SSHKEYDIR}" $USERNAME@"${line}" -t -t "echo "export 'LC_ALL=C'" >> /home/$USERNAME/.bashrc"
+			else
+				echo "LC_ALL=C has arelady setting"
+			fi
+		done
+		;;
+		login )
+			# ログインノード：パスワードレス設定
+			echo "ログインノード: confugring passwordless settings"
+			scp -o StrictHostKeyChecking=no -i "${SSHKEYDIR}" ./${VMPREFIX} $USERNAME@"${loginvmip}":/home/$USERNAME/.ssh/${VMPREFIX}
+			scp -o StrictHostKeyChecking=no -i "${SSHKEYDIR}" ./${VMPREFIX} $USERNAME@"${loginvmip}":/home/$USERNAME/.ssh/id_rsa
+			ssh -o StrictHostKeyChecking=no -i "${SSHKEYDIR}" $USERNAME@"${loginvmip}" -t -t "chmod 600 /home/$USERNAME/.ssh/id_rsa"
+			scp -o StrictHostKeyChecking=no -i "${SSHKEYDIR}" ./${VMPREFIX}.pub $USERNAME@"${loginvmip}":/home/$USERNAME/.ssh/${VMPREFIX}.pub
+			# SSH Config設定
+			scp -o StrictHostKeyChecking=no -i "${SSHKEYDIR}" ./config $USERNAME@"${loginvmip}":/home/$USERNAME/.ssh/config
+			ssh -o StrictHostKeyChecking=no -i "${SSHKEYDIR}" $USERNAME@"${loginvmip}" -t -t "chmod 600 /home/$USERNAME/.ssh/config"
+		;;
+	esac
+}
 
 case $1 in
 	create )
@@ -275,10 +488,10 @@ case $1 in
 		for count in $(seq 1 $MAXVM); do
 			# echo "creating nic # $count"
 			if [ ${STATICMAC} = "true" ]; then
-				az network nic create --name ${VMPREFIX}-${count}VMNic --resource-group $MyResourceGroup --vnet-name $MyNetwork --subnet $MySubNetwork --network-security --accelerated-networking true
+				az network nic create --name ${VMPREFIX}-"${count}"VMNic --resource-group $MyResourceGroup --vnet-name $MyNetwork --subnet $MySubNetwork --network-security --accelerated-networking true
 				echo "creating VM # ${count} with static nic"
 				# $ACCELERATEDNETWORKING: にはダブルクォーテーションはつけない
-				az vm create -g $MyResourceGroup -l $Location --name ${VMPREFIX}-${count} --size $VMSIZE --availability-set "$MyAvailabilitySet" --nics ${VMPREFIX}-${count}VMNic --image $IMAGE --admin-username $USERNAME --ssh-key-values $SSHKEYFILE --no-wait --tags "$TAG" -o none
+				az vm create -g $MyResourceGroup -l $Location --name ${VMPREFIX}-"${count}" --size $VMSIZE --availability-set "$MyAvailabilitySet" --nics ${VMPREFIX}-"${count}"VMNic --image $IMAGE --admin-username $USERNAME --ssh-key-values $SSHKEYFILE --no-wait --tags "$TAG" -o none
 			fi
 			echo "creating VM # $count with availability set: $MyAvailabilitySet"
 			# $ACCELERATEDNETWORKING: にはダブルクォーテーションはつけない
@@ -299,42 +512,8 @@ case $1 in
 			echo "sleep 45" && sleep 45
 		fi
 
-		# vmlist 作成
-		echo "creating vmlist and ipaddresslist"
-		az vm list-ip-addresses -g $MyResourceGroup --query "[].virtualMachine[].{Name:name, PrivateIPAddresses:network.privateIpAddresses[0], PublicIp:network.publicIpAddresses[0].ipAddress}" -o tsv > tmpfile
-		for count in $(seq 1 10); do
-			if [ -s tmpfile ]; then
-				break
-			else
-				az vm list-ip-addresses -g $MyResourceGroup --query "[].virtualMachine[].{Name:name, PrivateIPAddresses:network.privateIpAddresses[0], PublicIp:network.publicIpAddresses[0].ipAddress}" -o tsv > tmpfile
-				echo "getting list-ip-addresse... sleep 4" && sleep 4
-			fi
-		done
-		# pbs, loging, cyclecloud など削除
-		grep "tmcbmt01-[1-99]" ./tmpfile > ./tmpfile2
-		# 自然番号順にソート
-		sort -V ./tmpfile2 > tmpfile3
-		# vmlist 作成: $1
-		echo "creating vmlist"
-		cut -f 1 ./tmpfile3 > vmlist
-		numvm=$(cat ./vmlist | wc -l)
-		# ipaddresslist 作成: $3
-		echo "careating IP Address list"
-		cut -f 3 ./tmpfile3 > ipaddresslist
-		echo "ipaddresslist file contents"
-		cat ./ipaddresslist
-		# az vm list-ip-addresses --query を利用する場合、必要がない: sed -i -e '/^$/d' ./ipaddresslist
-		numip=$(cat ./ipaddresslist | wc -l)
-		# ipaddresslist チェック
-		if [ $((numip)) -eq $((MAXVM)) ]; then
-			echo "number of ipaddresslist and maxmv are matched."
-		else
-			echo "unmatched!"
-		fi
-		# テンポラリファイル削除
-		rm ./tmpfile
-		rm ./tmpfile2
-		rm ./tmpfile3
+		# vmlist and ipaddress 作成
+		getipaddresslist vmlist ipaddresslist
 
 		# 永続ディスクが必要な場合に設定可能
 		if [ $((PERMANENTDISK)) -gt 0 ]; then
@@ -372,9 +551,9 @@ case $1 in
 			if [ -n "$checkssh" ]; then
 				echo "${VMPREFIX}-${count}: configuring fstab by ssh"
 				#ssh -o StrictHostKeyChecking=no -i "${SSHKEYDIR}" $USERNAME@${line} -t -t "sudo sed -i -e '/azure_resource-part1/d' /etc/fstab"
-				ssh -o StrictHostKeyChecking=no -i "${SSHKEYDIR}" $USERNAME@${line} -t -t 'sudo umount /dev/disk/cloud/azure_resource-part1'
+				ssh -o StrictHostKeyChecking=no -i "${SSHKEYDIR}" $USERNAME@"${line}" -t -t 'sudo umount /dev/disk/cloud/azure_resource-part1'
 				# 重複していないかチェック
-				ssh -o StrictHostKeyChecking=no -i "${SSHKEYDIR}" $USERNAME@${line} -t -t "sudo grep ${mountip}:/mnt/resource/scratch /etc/fstab" > checkfstab
+				ssh -o StrictHostKeyChecking=no -i "${SSHKEYDIR}" $USERNAME@"${line}" -t -t "sudo grep ${mountip}:/mnt/resource/scratch /etc/fstab" > checkfstab
 				checkfstab=$(cat checkfstab | wc -l)
 				if [ $((checkfstab)) -ge 2 ]; then 
 					echo "deleting dupulicated settings...."
@@ -428,7 +607,7 @@ case $1 in
 			az vm run-command invoke -g $MyResourceGroup --name ${VMPREFIX}-1 --command-id RunShellScript --scripts "sudo mkdir -p /mnt/resource/scratch"
 			az vm run-command invoke -g $MyResourceGroup --name ${VMPREFIX}-1 --command-id RunShellScript --scripts "sudo chown ${USERNAME}:${USERNAME} /mnt/resource/scratch"
 			az vm run-command invoke -g $MyResourceGroup --name ${VMPREFIX}-1 --command-id RunShellScript --scripts "sudo systemctl start rpcbind && sudo systemctl start nfs-server"
-			az vm run-command invoke -g $MyResourceGroup --name ${VMPREFIX}-1 --command-id RunShellScript --scripts "sudo systemctl enable rpcbind && sudo systemctl enable nfs-server"
+			#az vm run-command invoke -g $MyResourceGroup --name ${VMPREFIX}-1 --command-id RunShellScript --scripts "sudo systemctl enable rpcbind && sudo systemctl enable nfs-server"
 		else
 			# SSH設定が高速なため、checkssh が有効な場合、SSHで実施
 			echo "${VMPREFIX}-1: sudo 設定"
@@ -445,14 +624,10 @@ case $1 in
 			ssh -o StrictHostKeyChecking=no -i "${SSHKEYDIR}" $USERNAME@"${vm1ip}" -t -t "sudo mkdir -p /mnt/resource/scratch"
 			ssh -o StrictHostKeyChecking=no -i "${SSHKEYDIR}" $USERNAME@"${vm1ip}" -t -t "sudo chown ${USERNAME}:${USERNAME} /mnt/resource/scratch"
 			ssh -o StrictHostKeyChecking=no -i "${SSHKEYDIR}" $USERNAME@"${vm1ip}" -t -t "sudo systemctl start rpcbind && sudo systemctl start nfs-server"
-			ssh -o StrictHostKeyChecking=no -i "${SSHKEYDIR}" $USERNAME@"${vm1ip}" -t -t "sudo systemctl enable rpcbind && sudo systemctl enable nfs-server"
+			#ssh -o StrictHostKeyChecking=no -i "${SSHKEYDIR}" $USERNAME@"${vm1ip}" -t -t "sudo systemctl enable rpcbind && sudo systemctl enable nfs-server"
 			ssh -o StrictHostKeyChecking=no -i "${SSHKEYDIR}" $USERNAME@"${vm1ip}" -t -t "sudo showmount -e"
 		fi
-		echo "setting up nfs client"
-		mountip=$(az vm show -g $MyResourceGroup --name ${VMPREFIX}-1 -d --query privateIps -otsv)
-		echo "mountip: $mountip"
-		# 1行目を削除したIPアドレスリストを作成
-		sed '1d' ./ipaddresslist > ./ipaddresslist-tmp
+
 		# sudo設定
 		echo "${VMPREFIX}-2 to ${MAXVM}: sudo 設定"
 		for count in $(seq 1 $((MAXVM-1))); do
@@ -471,43 +646,20 @@ case $1 in
 
 		# 高速化のためにSSHで一括設定しておく
 		echo "ssh parallel settings: nfs client"
-		parallel -a ipaddresslist-tmp "ssh -o StrictHostKeyChecking=no -o 'ConnectTimeout 30' -i ${SSHKEYDIR} $USERNAME@{} -t -t "sudo yum install --quiet -y nfs-utils epel-release""
-		parallel -a ipaddresslist-tmp "ssh -o StrictHostKeyChecking=no -o 'ConnectTimeout 30' -i ${SSHKEYDIR} $USERNAME@{} -t -t "sudo yum install --quiet -y htop""
-		parallel -a ipaddresslist-tmp "ssh -o StrictHostKeyChecking=no -o 'ConnectTimeout 30' -i ${SSHKEYDIR} $USERNAME@{} -t -t "sudo mkdir -p /mnt/resource/scratch""
-		parallel -a ipaddresslist-tmp "ssh -o StrictHostKeyChecking=no -o 'ConnectTimeout 30' -i ${SSHKEYDIR} $USERNAME@{} -t -t "sudo chown $USERNAME:$USERNAME /mnt/resource/scratch""
-		parallel -a ipaddresslist-tmp "ssh -o StrictHostKeyChecking=no -o 'ConnectTimeout 30' -i ${SSHKEYDIR} $USERNAME@{} -t -t "sudo mount -t nfs ${mountip}:/mnt/resource/scratch /mnt/resource/scratch""
+		# 1行目を削除したIPアドレスリストを作成
+		sed '1d' ./ipaddresslist > ./ipaddresslist-tmp
+		parallel -a ipaddresslist-tmp "ssh -o StrictHostKeyChecking=no -o 'ConnectTimeout 5' -i ${SSHKEYDIR} $USERNAME@{} -t -t "sudo yum install --quiet -y nfs-utils epel-release""
+		parallel -a ipaddresslist-tmp "ssh -o StrictHostKeyChecking=no -o 'ConnectTimeout 5' -i ${SSHKEYDIR} $USERNAME@{} -t -t "sudo yum install --quiet -y htop""
+		parallel -a ipaddresslist-tmp "ssh -o StrictHostKeyChecking=no -o 'ConnectTimeout 5' -i ${SSHKEYDIR} $USERNAME@{} -t -t "sudo mkdir -p /mnt/resource/scratch""
+		parallel -a ipaddresslist-tmp "ssh -o StrictHostKeyChecking=no -o 'ConnectTimeout 5' -i ${SSHKEYDIR} $USERNAME@{} -t -t "sudo chown $USERNAME:$USERNAME /mnt/resource/scratch""
+		parallel -a ipaddresslist-tmp "ssh -o StrictHostKeyChecking=no -o 'ConnectTimeout 5' -i ${SSHKEYDIR} $USERNAME@{} -t -t "sudo mount -t nfs ${mountip}:/mnt/resource/scratch /mnt/resource/scratch""
 		rm ./ipaddresslist-tmp
 
 		# NFSサーバ・マウント設定
-		for count in $(seq 2 $MAXVM); do
-			line=$(sed -n "${count}"P ./ipaddresslist)
-			for cnt in $(seq 1 10); do
-				checkssh=$(ssh -o StrictHostKeyChecking=no -o 'ConnectTimeout 30' -i "${SSHKEYDIR}" $USERNAME@"${line}" -t -t "uname")
-				if [ -n "$checkssh" ]; then
-					break
-				fi
-					# sshが成功しなければ継続してsleep
-					echo "waiting sshd @ ${VMPREFIX}-${count}: $checkssh sleep 10" && sleep 10
-			done
-			if [ -n "$checkssh" ]; then
-				echo "${VMPREFIX}-2 to ${MAXVM}: ${count} setting by ssh command"
-				ssh -o StrictHostKeyChecking=no -i "${SSHKEYDIR}" $USERNAME@"${line}" -t -t "sudo yum install --quiet -y nfs-utils epel-release"
-				# アフターインストール：epel-release
-				ssh -o StrictHostKeyChecking=no -i "${SSHKEYDIR}" $USERNAME@"${line}" -t -t "sudo yum install --quiet -y htop"
-				ssh -o StrictHostKeyChecking=no -i "${SSHKEYDIR}" $USERNAME@"${line}" -t -t "sudo mkdir -p /mnt/resource/scratch"
-				ssh -o StrictHostKeyChecking=no -i "${SSHKEYDIR}" $USERNAME@"${line}" -t -t "sudo chown $USERNAME:$USERNAME /mnt/resource/scratch"
-				ssh -o StrictHostKeyChecking=no -i "${SSHKEYDIR}" $USERNAME@"${line}" -t -t "sudo mount -t nfs ${mountip}:/mnt/resource/scratch /mnt/resource/scratch"
-			else
-				echo "${VMPREFIX}-2 to ${MAXVM}: ${count} setting by az vm run-command"
-				az vm run-command invoke -g $MyResourceGroup --name ${VMPREFIX}-"${count}" --command-id RunShellScript --scripts 'sudo yum install --quiet -y nfs-utils epel-release'
-				# アフターインストール：epel-release
-				az vm run-command invoke -g $MyResourceGroup --name ${VMPREFIX}-"${count}" --command-id RunShellScript --scripts 'sudo yum install --quiet -y htop'
-				az vm run-command invoke -g $MyResourceGroup --name ${VMPREFIX}-"${count}" --command-id RunShellScript --scripts "sudo mkdir -p /mnt/resource/scratch"
-				az vm run-command invoke -g $MyResourceGroup --name ${VMPREFIX}-"${count}" --command-id RunShellScript --scripts "sudo chown $USERNAME:$USERNAME /mnt/resource/scratch"
-				az vm run-command invoke -g $MyResourceGroup --name ${VMPREFIX}-"${count}" --command-id RunShellScript --scripts "sudo mount -t nfs ${mountip}:/mnt/resource/scratch /mnt/resource/scratch"
-			fi
-		done
-		echo "end of mouting ${mountip}:/mnt/resource/scratch"
+		echo "${VMPREFIX}-2 to ${MAXVM}: mouting VM#1"
+		mountdirectory vm1
+		echo "${VMPREFIX}-2 to ${MAXVM}: end of mouting ${mountip}:/mnt/resource/scratch"
+
 		# SSHパスワードレスセッティング
 		echo "preparing for passwordless settings"
 		cat ./ipaddresslist
@@ -519,55 +671,32 @@ StrictHostKeyChecking no
 UserKnownHostsFile=/dev/null
 EOL
 		echo "configuring passwordless settings"
-		parallel -a ipaddresslist "scp -o StrictHostKeyChecking=no -o 'ConnectTimeout 30' -i ${SSHKEYDIR} ./${VMPREFIX} $USERNAME@{}:/home/$USERNAME/.ssh/${VMPREFIX}"
-		parallel -a ipaddresslist "scp -o StrictHostKeyChecking=no -o 'ConnectTimeout 30' -i ${SSHKEYDIR} ./${VMPREFIX} $USERNAME@{}:/home/$USERNAME/.ssh/id_rsa"
-		parallel -a ipaddresslist "ssh -o StrictHostKeyChecking=no -o 'ConnectTimeout 30' -i ${SSHKEYDIR} $USERNAME@{} -t -t "chmod 600 /home/$USERNAME/.ssh/id_rsa""
-		parallel -a ipaddresslist "scp -o StrictHostKeyChecking=no -o 'ConnectTimeout 30' -i ${SSHKEYDIR} ./${VMPREFIX}.pub $USERNAME@{}:/home/$USERNAME/.ssh/${VMPREFIX}.pub"
+		parallel -a ipaddresslist "scp -o StrictHostKeyChecking=no -o 'ConnectTimeout 5' -i ${SSHKEYDIR} ./${VMPREFIX} $USERNAME@{}:/home/$USERNAME/.ssh/${VMPREFIX}"
+		parallel -a ipaddresslist "scp -o StrictHostKeyChecking=no -o 'ConnectTimeout 5' -i ${SSHKEYDIR} ./${VMPREFIX} $USERNAME@{}:/home/$USERNAME/.ssh/id_rsa"
+		parallel -a ipaddresslist "ssh -o StrictHostKeyChecking=no -o 'ConnectTimeout 5' -i ${SSHKEYDIR} $USERNAME@{} -t -t "chmod 600 /home/$USERNAME/.ssh/id_rsa""
+		parallel -a ipaddresslist "scp -o StrictHostKeyChecking=no -o 'ConnectTimeout 5' -i ${SSHKEYDIR} ./${VMPREFIX}.pub $USERNAME@{}:/home/$USERNAME/.ssh/${VMPREFIX}.pub"
 		# SSH追加設定
 		for count in $(seq 1 $MAXVM) ; do
 			line=$(sed -n "${count}"P ./ipaddresslist)
 			scp -o StrictHostKeyChecking=no -i "${SSHKEYDIR}" ./config $USERNAME@"${line}":/home/$USERNAME/.ssh/config
 			ssh -o StrictHostKeyChecking=no -i "${SSHKEYDIR}" $USERNAME@"${line}" -t -t "chmod 600 /home/$USERNAME/.ssh/config"
 		done
+
 		# ホストファイル事前バックアップ（PBSノード追加設定向け）
 		echo "backup original hosts file"
-		parallel -a ipaddresslist "ssh -o StrictHostKeyChecking=no -o 'ConnectTimeout 30' -i ${SSHKEYDIR} $USERNAME@{} "sudo cp /etc/hosts /etc/hosts.original""
-		# PBSノード：マウント設定
-		echo "pbsnode: nfs server @ ${VMPREFIX}-pbs"
-		# PBSノード：名前取得
-		pbsvmname=$(az vm show -d -g $MyResourceGroup --name ${VMPREFIX}-pbs --query name -o tsv)
+		parallel -a ipaddresslist "ssh -o StrictHostKeyChecking=no -o 'ConnectTimeout 5' -i ${SSHKEYDIR} $USERNAME@{} "sudo cp /etc/hosts /etc/hosts.original""
+
 		# PBSノードがなければ終了
 		if [ -z "$pbsvmname" ]; then
 			echo "no PBS node here!"
 			exit 0
 		fi
-		# PBSノード：グローバルIPアドレス取得
-		pbsvmip=$(az vm show -d -g $MyResourceGroup --name ${VMPREFIX}-pbs --query publicIps -o tsv)
-		echo "${VMPREFIX}-pbs's public ip: $pbsvmip"
-		# PBSノード：マウント向けプライベートIPアドレス取得
-		pbsmountip=$(az vm show -g $MyResourceGroup --name ${VMPREFIX}-pbs -d --query privateIps -otsv)
-		echo "${VMPREFIX}-pbs's exports ip: $pbsmountip"
-		# インターネットからアクセス可能であれば、SSHで高速に設定する
-		# PBSノードのパブリックIPの判定
-		if [ -z "$pbsvmip" ]; then
-			# PBSノードのパブリックIPが空で、IPアドレスが取得できなければ、az cliでの取得
-			echo "pbsnode: confuguring nfs mount by by az vmruuning-commands"
-			for count in $(seq 1 $MAXVM) ; do
-				# コンピュートノード#1の/mnt/resource/scratchをマウント
-				az vm run-command invoke -g $MyResourceGroup --name ${VMPREFIX}-"${count}" --command-id RunShellScript --scripts "sudo mkdir -p /mnt/share"
-				az vm run-command invoke -g $MyResourceGroup --name ${VMPREFIX}-"${count}" --command-id RunShellScript --scripts "sudo chown $USERNAME:$USERNAME /mnt/share"
-				az vm run-command invoke -g $MyResourceGroup --name ${VMPREFIX}-"${count}" --command-id RunShellScript --scripts "sudo mount -t nfs ${pbsmountip}:/mnt/share /mnt/share"
-			done
-		else
-			echo "pbsnode: confuguring nfs mount by ssh"
-			# pbsbmipが空でなければSSHでマウント情報の取得
-			echo "${VMPREFIX}-1: $pbsvmip"
-			ssh -o StrictHostKeyChecking=no -i "${SSHKEYDIR}" $USERNAME@"${pbsvmip}" 'sudo showmount -e'
-			echo "${VMPREFIX}-1 to ${MAXVM}: mounting ${VMPREFIX}-pbs /mnt/share"
-			parallel -a ipaddresslist "ssh -o StrictHostKeyChecking=no -i ${SSHKEYDIR} $USERNAME@{} -t -t "sudo mkdir -p /mnt/share""
-			parallel -a ipaddresslist "ssh -o StrictHostKeyChecking=no -i ${SSHKEYDIR} $USERNAME@{} -t -t "sudo chown $USERNAME:$USERNAME /mnt/share""
-			parallel -a ipaddresslist "ssh -o StrictHostKeyChecking=no -i ${SSHKEYDIR} $USERNAME@{} -t -t "sudo mount -t nfs ${pbsmountip}:/mnt/share /mnt/share""
-		fi
+
+		# PBSノード：マウント設定
+		echo "pbsnode: nfs server @ ${VMPREFIX}-pbs"
+		mountdirectory pbs
+		echo "${VMPREFIX}-1 to ${MAXVM}: end of mouting ${pbsmountip}:/mnt/share"
+
 		# PBSノードがある場合にのみ、ホストファイル作成
 		# ホストファイル作成準備：既存ファイル削除
 		if [ -f ./vmlist ]; then rm ./vmlist; echo "recreating a new vmlist"; fi
@@ -800,687 +929,9 @@ EOL
 		ssh -o StrictHostKeyChecking=no -i "${SSHKEYDIR}" $USERNAME@"${pbsvmip}" -t -t "sudo cp /home/$USERNAME/.ssh/authorized_keys /root/.ssh/authorized_keys"
 		# ジョブスケジューラセッティング
 		ssh -o StrictHostKeyChecking=no -i "${SSHKEYDIR}" root@"${pbsvmip}" -t -t "bash /home/$USERNAME/setuppbs.sh"
-### ===========================================================================
-	;;
-	start )
-		## PBSノード：OSディスクタイプ変更: Premium_LRS
-		azure_sku2="Premium_LRS"
-		# PBSノードの存在チェック
-		osdiskidpbs=$(az vm show -g $MyResourceGroup --name ${VMPREFIX}-pbs --query storageProfile.osDisk.managedDisk.id -o tsv)
-		if [ -n "$osdiskidpbs" ]; then
-			az disk update --sku ${azure_sku2} --ids "${osdiskidpbs}" -o table
-			echo "starting PBS VM"
-			az vm start -g $MyResourceGroup --name ${VMPREFIX}-pbs -o none &
-			# 今のところPBSノードが存在すればログインノードも存在する
-			echo "starting loging VM"
-			az vm start -g $MyResourceGroup --name ${VMPREFIX}-login -o none &
-		else
-			# PBSノードのOSディスクが存在しなければPBSノードも存在しない
-			echo "no PBS node here!"
-		fi
-		echo "starting VM ${VMPREFIX}-1"
-		az vm start -g $MyResourceGroup --name ${VMPREFIX}-1 -o none &
-		echo "starting VM ${VMPREFIX}:2-$MAXVM compute nodes"
-		seq 2 $MAXVM | parallel "az vm start -g $MyResourceGroup --name ${VMPREFIX}-{} -o none &"
-		sleep 60
-		echo "checking $MAXVM compute VM's status"
-		numvm=0
-		tmpnumvm="default"
-		while [ -n "$tmpnumvm" ]; do
-			tmpnumvm=$(az vm list -d -g $MyResourceGroup --query "[?powerState=='VM starting']" -o tsv)
-			echo "$tmpnumvm" | tr ' ' '\n' > ./tmpnumvm.txt
-			numvm=$(grep -c "starting" ./tmpnumvm.txt)
-			echo "current starting VMs: $numvm. All VMs are already running!"
-			sleep 5
-		done
-		rm ./tmpnumvm.txt
-
-		# ダイナミックの場合（デフォルト）、再度IPアドレスリストを作成しなおす
-		if [ ! -f ./ipaddresslist ]; then rm ./ipaddresslist; fi
-		echo "creating ipaddresslist"
-		az vm list-ip-addresses -g $MyResourceGroup --query "[].virtualMachine[].{Name:name, PrivateIPAddresses:network.privateIpAddresses[0], PublicIp:network.publicIpAddresses[0].ipAddress}" -o tsv > tmpfile
-		# 自然な順番でソートする
-		sort -V ./tmpfile > tmpfile2
-		# ipaddresslist 取り出し：3列目
-		echo "show new ipaddresslist"
-		cut -f 3 ./tmpfile2 > ipaddresslist
-		cat ./ipaddresslist
-
-		# コンピュートノードVM#1のマウントするプライベートIPの取得
-		mountip=$(az vm show -g $MyResourceGroup --name ${VMPREFIX}-1 -d --query privateIps -o tsv)
-		echo "${VMPREFIX}-1: nfs exports ip: $mountip"
-		# インターネットからアクセス可能であれば、SSHで高速に設定する
-		if [ -z "$vm1ip" ]; then
-			# vm1ipがパブリックIPが空でIPアドレスが取得できなければ、az cliでの取得
-			# コンピュートノード#1：マウント設定
-			echo "nfs server @ ${VMPREFIX}-1"
-			az vm run-command invoke -g $MyResourceGroup --name ${VMPREFIX}-1 --command-id RunShellScript --scripts "sudo showmount -e"
-			for count in $(seq 2 $MAXVM) ; do
-				# 並列化・時間短縮は検討事項
-				echo "${VMPREFIX}-1: configuring nfs mount by az vmruuning-commands"
-				az vm run-command invoke -g $MyResourceGroup --name ${VMPREFIX}-"${count}" --command-id RunShellScript --scripts "sudo mkdir -p /mnt/resource/scratch"
-				az vm run-command invoke -g $MyResourceGroup --name ${VMPREFIX}-"${count}" --command-id RunShellScript --scripts "sudo chown $USERNAME:$USERNAME /mnt/resource/scratch"
-				az vm run-command invoke -g $MyResourceGroup --name ${VMPREFIX}-"${count}" --command-id RunShellScript --scripts "sudo mount $DEBUG -t nfs ${mountip}:/mnt/resource/scratch /mnt/resource/scratch"
-			done
-		else
-			# vm1ipが空でなければSSHでマウントを実施
-			echo "${VMPREFIX}-1: confuguring nfs mount by ssh"
-			echo "${VMPREFIX}-1: $vm1ip"
-			ssh -o StrictHostKeyChecking=no -i "${SSHKEYDIR}" $USERNAME@"${vm1ip}" 'sudo showmount -e'
-			# 1行目を削除したIPアドレスリストを作成
-			sed '1d' ./ipaddresslist > ./ipaddresslist-tmp
-			echo "${VMPREFIX}-2 to $MAXVM: mounting ${VMPREFIX}-1 /mnt/resource/scratch"
-			parallel -a ipaddresslist-tmp "ssh -o StrictHostKeyChecking=no -i ${SSHKEYDIR} $USERNAME@{} -t -t "sudo mkdir -p /mnt/resource/scratch""
-			parallel -a ipaddresslist-tmp "ssh -o StrictHostKeyChecking=no -i ${SSHKEYDIR} $USERNAME@{} -t -t "sudo chown $USERNAME:$USERNAME /mnt/resource/scratch""
-			parallel -a ipaddresslist-tmp "ssh -o StrictHostKeyChecking=no -i ${SSHKEYDIR} $USERNAME@{} -t -t "sudo mount -t nfs ${mountip}:/mnt/resource/scratch /mnt/resource/scratch""
-		fi
-		echo "end of starting up computing nodes"
-		# PBSノードがなければ終了
-		if [ -z "$osdiskidpbs" ]; then
-			echo "no PBS node here!"
-			exit 0
-		fi
-		# PBSノード：マウント設定
-		echo "pbsnode: nfs server @ ${VMPREFIX}-pbs"
-		# PBSノード：名前取得
-		pbsvmname=$(az vm show -d -g $MyResourceGroup --name ${VMPREFIX}-pbs --query name -o tsv)
-		# PBSノード：グローバルIPアドレス取得
-		pbsvmip=$(az vm show -d -g $MyResourceGroup --name ${VMPREFIX}-pbs --query publicIps -o tsv)
-		echo "${VMPREFIX}-pbs's public ip: $pbsvmip"
-		# PBSノード：マウント向けプライベートIPアドレス取得
-		pbsmountip=$(az vm show -g $MyResourceGroup --name ${VMPREFIX}-pbs -d --query privateIps -otsv)
-		echo "${VMPREFIX}-pbs's exports ip: $pbsmountip"
-		# インターネットからアクセス可能であれば、SSHで高速に設定する
-		if [ -n "$pbsvmname" ]; then
-			# vm1ipが空なら、IPアドレスが取得できなければ、az cliでの取得
-			if [ -z "$pbsvmip" ]; then
-				echo "pbsnode: confuguring nfs mount by by az vmruuning-commands"
-				# コンピュートノード#1のみ実施
-				az vm run-command invoke -g $MyResourceGroup --name ${VMPREFIX}-1 --command-id RunShellScript --scripts "sudo mkdir -p /mnt/share"
-				az vm run-command invoke -g $MyResourceGroup --name ${VMPREFIX}-1 --command-id RunShellScript --scripts "sudo chown $USERNAME:$USERNAME /mnt/share"
-				az vm run-command invoke -g $MyResourceGroup --name ${VMPREFIX}-1 --command-id RunShellScript --scripts "sudo mount -t nfs ${pbsmountip}:/mnt/share /mnt/share"
-				for count in $(seq 2 $MAXVM) ; do
-				# コンピュートノード#1をマウント
-					az vm run-command invoke -g $MyResourceGroup --name ${VMPREFIX}-"${count}" --command-id RunShellScript --scripts "sudo mkdir -p /mnt/share"
-					az vm run-command invoke -g $MyResourceGroup --name ${VMPREFIX}-"${count}" --command-id RunShellScript --scripts "sudo chown $USERNAME:$USERNAME /mnt/share"
-					az vm run-command invoke -g $MyResourceGroup --name ${VMPREFIX}-"${count}" --command-id RunShellScript --scripts "sudo mount -t nfs ${pbsmountip}:/mnt/share /mnt/share"
-				done
-			else
-				echo "pbsnode: confuguring nfs mount by ssh"
-				# pbsbmipが空でなければSSHでマウント情報の取得
-				echo "${VMPREFIX}-1: $pbsvmip"
-				ssh -o StrictHostKeyChecking=no -i "${SSHKEYDIR}" $USERNAME@"${pbsvmip}" 'sudo showmount -e'
-				echo "${VMPREFIX}-1 to $MAXVM: mounting ${VMPREFIX}-pbs /mnt/share"
-				parallel -a ipaddresslist "ssh -o StrictHostKeyChecking=no -i ${SSHKEYDIR} $USERNAME@{} -t -t "sudo mkdir -p /mnt/share""
-				parallel -a ipaddresslist "ssh -o StrictHostKeyChecking=no -i ${SSHKEYDIR} $USERNAME@{} -t -t "sudo chown $USERNAME:$USERNAME /mnt/share""
-				parallel -a ipaddresslist "ssh -o StrictHostKeyChecking=no -i ${SSHKEYDIR} $USERNAME@{} -t -t "sudo mount -t nfs ${pbsmountip}:/mnt/share /mnt/share""
-				# vm1ipが空でなければSSHでマウント情報の取得
-				echo "${VMPREFIX}-1: $vm1ip"
-				ssh -o StrictHostKeyChecking=no -i "${SSHKEYDIR}" $USERNAME@"${vm1ip}" 'sudo showmount -e'
-				echo "${VMPREFIX}-2 to $MAXVM: mounting ${VMPREFIX}-1 /mnt/resource/scratch"
-				parallel -a ipaddresslist-tmp "ssh -o StrictHostKeyChecking=no -i ${SSHKEYDIR} $USERNAME@{} -t -t "sudo mkdir -p /mnt/resource/scratch""
-				parallel -a ipaddresslist-tmp "ssh -o StrictHostKeyChecking=no -i ${SSHKEYDIR} $USERNAME@{} -t -t "sudo chown $USERNAME:$USERNAME /mnt/resource/scratch""
-				parallel -a ipaddresslist-tmp "ssh -o StrictHostKeyChecking=no -i ${SSHKEYDIR} $USERNAME@{} -t -t "sudo mount -t nfs ${mountip}:/mnt/resource/scratch /mnt/resource/scratch""
-			fi
-			echo "end of PBS mount check"
-		fi
-		rm ./ipaddresslist-tmp
-		echo "end of start command"
-	;;
-	startvm )
-		# PBSノードの存在チェック
-		osdiskidpbs=$(az vm show -g $MyResourceGroup --name ${VMPREFIX}-pbs --query storageProfile.osDisk.managedDisk.id -o tsv)
-		# VM # $2 起動開始
-		echo "starting VM ${VMPREFIX}-$2"
-		az vm start -g $MyResourceGroup --name ${VMPREFIX}-"$2" -o none &
-		echo "checking VM public ip"
-		# ダイナミックの場合（デフォルト）、再度IPアドレスリストを作成しなおす
-		# コンピュートノードVM#1のパブリックIPが同じならスキップする
-		vmip=$(az vm show -d -g $MyResourceGroup --name ${VMPREFIX}-"$2" --query publicIps -o tsv)
-		existvmip=$(sed -n "${2}"P ./ipaddresslist)
-		echo "new ${VMPREFIX}-1's IP: $vm1ip"
-		# 置換実施
-		if [ "$existvmip" !=  "$vmip" ]; then
-			echo "making new vm $2 ipaddress replace in the list"
-			sed "$2c $vmip" ./ipaddresslist
-			echo "new ipaddress list"
-			cat ./ipaddresslist
-		else
-			echo "not canage vm $2 ipaddress list"
-		fi
-		# コンピュートノードVM#1のマウントするプライベートIPの取得
-		mountip=$(az vm show -g $MyResourceGroup --name ${VMPREFIX}-1 -d --query privateIps -o tsv)
-		echo "${VMPREFIX}-1: nfs exports ip: $mountip"
-		checkssh=$(ssh -o StrictHostKeyChecking=no -o 'ConnectTimeout 30' -i "${SSHKEYDIR}" -t $USERNAME@"${vmip}" "uname")
-		# インターネットからアクセス可能であれば、SSHで高速に設定する
-		if [ -z "$vmip" ]; then
-			# vmipがパブリックIPが空でIPアドレスが取得できなければ、az cliでの取得
-				echo "${VMPREFIX}-1: configuring nfs mount by az vmruuning-commands"
-				az vm run-command invoke -g $MyResourceGroup --name ${VMPREFIX}-"$2" --command-id RunShellScript --scripts "sudo mkdir -p /mnt/resource/scratch"
-				az vm run-command invoke -g $MyResourceGroup --name ${VMPREFIX}-"$2" --command-id RunShellScript --scripts "sudo chown $USERNAME:$USERNAME /mnt/resource/scratch"
-				az vm run-command invoke -g $MyResourceGroup --name ${VMPREFIX}-"$2" --command-id RunShellScript --scripts "sudo mount $DEBUG -t nfs ${mountip}:/mnt/resource/scratch /mnt/resource/scratch"
-		else
-			echo "${VMPREFIX}-$2: mounting ${VMPREFIX}-$2 /mnt/resource/scratch"
-			ssh -o StrictHostKeyChecking=no -i "${SSHKEYDIR}" $USERNAME@"${vmip}" -t -t "sudo mkdir -p /mnt/resource/scratch"
-			ssh -o StrictHostKeyChecking=no -i "${SSHKEYDIR}" $USERNAME@"${vmip}" -t -t "sudo chown $USERNAME:$USERNAME /mnt/resource/scratch"
-			ssh -o StrictHostKeyChecking=no -i "${SSHKEYDIR}" $USERNAME@"${vmip}" -t -t "sudo mount $DEBUG -t nfs ${mountip}:/mnt/resource/scratch /mnt/resource/scratch"
-		fi
-		echo "end of starting up computing nodes"
-		# PBSノードがなければ終了
-		if [ -z "$osdiskidpbs" ]; then
-			echo "no PBS node here!"
-			exit 0
-		fi
-		# PBSノード：マウント設定
-		echo "pbsnode: nfs server @ ${VMPREFIX}-pbs"
-		# PBSノード：名前取得
-		pbsvmname=$(az vm show -d -g $MyResourceGroup --name ${VMPREFIX}-pbs --query name -o tsv)
-		# PBSノード：グローバルIPアドレス取得
-		pbsvmip=$(az vm show -d -g $MyResourceGroup --name ${VMPREFIX}-pbs --query publicIps -o tsv)
-		echo "${VMPREFIX}-pbs's public ip: $pbsvmip"
-		# PBSノード：マウント向けプライベートIPアドレス取得
-		pbsmountip=$(az vm show -g $MyResourceGroup --name ${VMPREFIX}-pbs -d --query privateIps -otsv)
-		echo "${VMPREFIX}-pbs's exports ip: $pbsmountip"
-		# インターネットからアクセス可能であれば、SSHで高速に設定する
-		if [ -n "$pbsvmname" ]; then
-			# vm1ipが空なら、IPアドレスが取得できなければ、az cliでの取得
-			if [ -z "$pbsvmip" ]; then
-				echo "pbsnode: confuguring nfs mount by by az vmruuning-commands"
-				# コンピュートノード# $2 実施: PBS 
-				az vm run-command invoke -g $MyResourceGroup --name ${VMPREFIX}-"$2" --command-id RunShellScript --scripts "sudo mkdir -p /mnt/share"
-				az vm run-command invoke -g $MyResourceGroup --name ${VMPREFIX}-"$2"--command-id RunShellScript --scripts "sudo chown $USERNAME:$USERNAME /mnt/share"
-				az vm run-command invoke -g $MyResourceGroup --name ${VMPREFIX}-"$2" --command-id RunShellScript --scripts "sudo mount $DEBUG -t nfs ${pbsmountip}:/mnt/share /mnt/share"
-			else
-				echo "pbsnode: confuguring nfs mount by ssh"
-				# pbsbmipが空でなければSSHでマウント情報の取得
-				echo "${VMPREFIX}-1: $pbsvmip"
-				ssh -o StrictHostKeyChecking=no -i "${SSHKEYDIR}" $USERNAME@"${pbsvmip}" 'sudo showmount -e'
-				echo "${VMPREFIX}-1 to $MAXVM: mounting ${VMPREFIX}-pbs /mnt/share"
-				ssh -o StrictHostKeyChecking=no -i "${SSHKEYDIR}" $USERNAME@"${vmip}" -t -t "sudo mkdir -p /mnt/share"
-				ssh -o StrictHostKeyChecking=no -i "${SSHKEYDIR}" $USERNAME@"${vmip}" -t -t "sudo chown $USERNAME:$USERNAME /mnt/share"
-				ssh -o StrictHostKeyChecking=no -i "${SSHKEYDIR}" $USERNAME@"${vmip}" -t -t "sudo mount $DEBUG -t nfs ${pbsmountip}:/mnt/share /mnt/share"
-			fi
-			echo "end of PBS mount check"
-		fi
-		rm ./ipaddresslist-tmp
-		echo "end of start command"
-	;;
-	stop )
-		for count in $(seq 1 $MAXVM) ; do
-			echo "stoping VM $count"
-			az vm deallocate -g $MyResourceGroup --name ${VMPREFIX}-"${count}" &
-		done
-	;;
-	stop-all )
-		if [ -f ./tmposdiskidlist ]; then rm ./tmposdiskidlist; fi
-		for count in $(seq 1 $MAXVM) ; do
-			disktmp=$(az vm show -g $MyResourceGroup --name ${VMPREFIX}-"${count}" --query storageProfile.osDisk.managedDisk.id -o tsv)
-			echo "$disktmp" >> tmposdiskidlist
-		done
-		for count in $(seq 1 $MAXVM) ; do
-			echo "stoping VM $count"
-			az vm deallocate -g $MyResourceGroup --name ${VMPREFIX}-"${count}" &
-		done
-		echo "stoping PBS VM"
-		az vm deallocate -g $MyResourceGroup --name ${VMPREFIX}-pbs &
-		echo "stoping login VM"
-		az vm deallocate -g $MyResourceGroup --name ${VMPREFIX}-login &
-		# OSディスクタイプ変更: Standard_LRS
-		azure_sku1="Standard_LRS"
-		echo "converting computing node OS disk"
-		parallel -v -a ./tmposdiskidlist "az disk update --sku ${azure_sku1} --ids {}"
-		# Dataディスクタイプ変更: Standard_LRS
-		echo "converting PBS node data disk"
-		az vm show -g $MyResourceGroup --name ${VMPREFIX}-pbs --query storageProfile.dataDisks[*].managedDisk -o tsv | awk -F" " '{print $2}' | xargs -I{} az disk update --sku ${azure_sku1} --ids {}
-		echo "converting compute node #1 data disk"
-		az vm show -g $MyResourceGroup --name ${VMPREFIX}-1 --query storageProfile.dataDisks[*].managedDisk -o tsv | awk -F" " '{print $2}' | xargs -I{} az disk update --sku ${azure_sku1} --ids {}
-	;;
-	stopvm )
-		echo "コマンドシンタクス:VM#2を停止する場合 ./$CMDNAME stopvm 2"
-		echo "stoping VM $2"
-		az vm deallocate -g $MyResourceGroup --name ${VMPREFIX}-"$2" &
-	;;
-	stopvms )
-		echo "コマンドシンタクス:VM#2,3,4を停止する場合 ./$CMDNAME stopvm 2 4"
-		echo "stoping VM $2 $3"
-		for count in $(seq "$2" "$3") ; do
-			echo "stoping VM $count"
-			az vm deallocate -g $MyResourceGroup --name ${VMPREFIX}-"${count}" &
-		done
-	;;
-	list )
-		echo "listng running/stopped VM"
-		az vm list -g $MyResourceGroup -d -o table
-
-		echo "prep..."
-		getipaddresslist 1 2
-		echo "nfs server vm status"
-		# vm1state=$(az vm show -d -g $MyResourceGroup --name ${VMPREFIX}-1 --query powerState)
-		vm1ip=$(az vm show -d -g $MyResourceGroup --name ${VMPREFIX}-1 --query publicIps -o tsv)
-		pbsvmip=$(az vm show -d -g $MyResourceGroup --name ${VMPREFIX}-pbs --query publicIps -o tsv)
-		# PBSノードのパブリックIPアドレスの判定
-		if [ -z "$pbsvmip" ]; then
-			echo "no PBS node here! checking only compute nodes."
-			# コンピュートノードのみのチェック
-			count=0
-			checkssh=$(ssh -o StrictHostKeyChecking=no -o 'ConnectTimeout 30' -i "${SSHKEYDIR}" -t $USERNAME@"${vm1ip}" "uname")
-			if [ -n "$checkssh" ]; then
-				echo "${VMPREFIX}-1: nfs server status"
-				ssh -o StrictHostKeyChecking=no -i "${SSHKEYDIR}" $USERNAME@"${vm1ip}" 'sudo showmount -e'
-				echo "nfs client mount status"
-					for count in $(seq 2 $MAXVM); do
-						line=$(sed -n "${count}"P ./ipaddresslist)
-						ssh -o StrictHostKeyChecking=no -i "${SSHKEYDIR}" -t -t $USERNAME@"${line}" "echo '########## host: ${VMPREFIX}-${count} ##########'"
-						ssh -o StrictHostKeyChecking=no -i "${SSHKEYDIR}" -t -t $USERNAME@"${line}" "df | grep '/mnt/'"
-					done
-				else
-					# SSHできないのでaz vm run-commandでの情報取得
-					echo "az vm run-command: nfs server status"
-					az vm run-command invoke -g $MyResourceGroup --name ${VMPREFIX}-1 --command-id RunShellScript --scripts "sudo showmount -e"
-					echo "nfs client mount status:=======1-2 others: skiped======="
-					az vm run-command invoke -g $MyResourceGroup --name ${VMPREFIX}-1 --command-id RunShellScript --scripts "df | grep /mnt/"
-					az vm run-command invoke -g $MyResourceGroup --name ${VMPREFIX}-2 --command-id RunShellScript --scripts "df | grep /mnt/"
-			fi
-			# コンピュートノードVM#1のマウントだけ完了し、コマンド完了
-			echo "end of list command"
-			exit 0
-		fi
-		# PBSノード、コンピュートノードのNFSマウント確認
-		count=0
-		checkssh=$(ssh -o StrictHostKeyChecking=no -o 'ConnectTimeout 30' -i "${SSHKEYDIR}" -t $USERNAME@"${vm1ip}" "uname")
-		checkssh2=$(ssh -o StrictHostKeyChecking=no -o 'ConnectTimeout 30' -i "${SSHKEYDIR}" -t $USERNAME@"${pbsvmip}" "uname")
-		if [ -n "$checkssh" ] && [ -n "$checkssh2" ]; then
-			echo "${VMPREFIX}-pbs: nfs server status"
-			ssh -o StrictHostKeyChecking=no -i "${SSHKEYDIR}" $USERNAME@"${pbsvmip}" 'sudo showmount -e'
-			echo "${VMPREFIX}-1: nfs server status"
-			ssh -o StrictHostKeyChecking=no -i "${SSHKEYDIR}" $USERNAME@"${vm1ip}" 'sudo showmount -e'
-			echo "nfs client mount status"
-			for count in $(seq 2 $MAXVM); do
-				line=$(sed -n "${count}"P ./ipaddresslist)
-				ssh -o StrictHostKeyChecking=no -i "${SSHKEYDIR}" -t -t $USERNAME@"${line}" "echo '########## host: ${VMPREFIX}-${count} ##########'"
-				ssh -o StrictHostKeyChecking=no -i "${SSHKEYDIR}" -t -t $USERNAME@"${line}" "df | grep '/mnt/'"
-			done
-		else
-			echo "az vm run-command: nfs server status"
-			az vm run-command invoke -g $MyResourceGroup --name ${VMPREFIX}-pbs --command-id RunShellScript --scripts "sudo showmount -e"
-			az vm run-command invoke -g $MyResourceGroup --name ${VMPREFIX}-1 --command-id RunShellScript --scripts "sudo showmount -e"
-			echo "nfs client mount status:=======VM 1-2'status. other VMs are skiped======="
-			az vm run-command invoke -g $MyResourceGroup --name ${VMPREFIX}-1 --command-id RunShellScript --scripts "df | grep /mnt/"
-			az vm run-command invoke -g $MyResourceGroup --name ${VMPREFIX}-2 --command-id RunShellScript --scripts "df | grep /mnt/"
-		fi
-	;;
-	delete )
-		if [ -f ./tmposdiskidlist ]; then rm ./tmposdiskidlist; fi
-		for count in $(seq 1 $MAXVM) ; do
-			disktmp=$(az vm show -g $MyResourceGroup --name ${VMPREFIX}-"${count}" --query storageProfile.osDisk.managedDisk.id -o tsv)
-			echo "$disktmp" >> tmposdiskidlist
-		done
-		echo "deleting compute VMs"
-		seq 1 $MAXVM | parallel "az vm delete -g $MyResourceGroup --name ${VMPREFIX}-{} --yes &"
-		numvm=$(cat ./vmlist | wc -l)
-		checkpbs=$(grep pbs ./vmlist)
-		if [ -n "$checkpbs" ]; then
-			# no pbs
-			while [ $((numvm)) -gt 2 ]; do
-				echo "sleep 30" && sleep 30
-				echo "current running VMs: $numvm"
-				az vm list -g $MyResourceGroup | jq '.[] | .name' | grep ${VMPREFIX} > ./vmlist
-				numvm=$(cat ./vmlist | wc -l)
-			done
-		echo "deleted all compute VMs"
-		else
-			# pbs node existing
-			while [ $((numvm)) -gt 0 ]; do
-				echo "sleep 30" && sleep 30
-				echo "current running VMs: $numvm"
-				az vm list -g $MyResourceGroup | jq '.[] | .name' | grep ${VMPREFIX} > ./vmlist
-				numvm=$(cat ./vmlist | wc -l)
-			done
-		fi
-		echo "deleted all compute VMs. PBS and login node are existing"
-		echo "deleting disk"
-		parallel -a tmposdiskidlist "az disk delete --ids {} --yes"
-		sleep 10
-		# STATICMAC が true であればNIC、パブリックIPを再利用する
-		if [ "$STATICMAC" == "true" ] || [ "$STATICMAC" == "TRUE" ]; then
-			echo "keep existing nic and public ip"
-		else
-			echo "deleting nic"
-			seq 1 $MAXVM | parallel "az network nic delete -g $MyResourceGroup --name ${VMPREFIX}-{}VMNic"
-			echo "deleting public ip"
-			seq 1 $MAXVM | parallel "az network public-ip delete -g $MyResourceGroup --name ${VMPREFIX}-{}PublicIP"
-		fi
-		echo "detele data disk"
-		az disk delete -g $MyResourceGroup --name ${VMPREFIX}-1-disk0 --yes
-		echo "current running VMs: ${numvm}"
-		# ファイル削除
-		rm ./ipaddresslist
-		rm ./tmposdiskidlist
-		rm ./vmlist
-		rm ./nodelist
-	;;
-	delete-all )
-		if [ -f ./tmposdiskidlist ]; then
-			rm ./tmposdiskidlist
-		fi
-		for count in $(seq 1 $MAXVM) ; do
-			disktmp=$(az vm show -g $MyResourceGroup --name ${VMPREFIX}-"${count}" --query storageProfile.osDisk.managedDisk.id -o tsv)
-			echo "$disktmp" >> tmposdiskidlist
-		done
-		disktmp=$(az vm show -g $MyResourceGroup --name ${VMPREFIX}-pbs --query storageProfile.osDisk.managedDisk.id -o tsv)
-		echo "$disktmp" >> tmposdiskidlist
-		disktmp=$(az vm show -g $MyResourceGroup --name ${VMPREFIX}-login --query storageProfile.osDisk.managedDisk.id -o tsv)
-		echo "$disktmp" >> tmposdiskidlist
-		echo "deleting compute VMs"
-		seq 1 $MAXVM | parallel "az vm delete -g $MyResourceGroup --name ${VMPREFIX}-{} --yes &"
-		echo "deleting pbs node"
-		az vm delete -g $MyResourceGroup --name ${VMPREFIX}-pbs --yes &
-		echo "deleting login node"
-		az vm delete -g $MyResourceGroup --name ${VMPREFIX}-login --yes &
-		# vmlistがある前提
-		if [ ! -f "./vmlist" ]; then 
-			numvm=$(cat ./vmlist | wc -l)
-		else
-			numvm=$((MAXVM))
-		fi
-		# VM削除までの待ち時間
-		while [ $((numvm)) -gt 0 ]; do
-			echo "sleep 30" && sleep 30
-			echo "current running VMs: $numvm"
-			az vm list -g $MyResourceGroup | jq '.[] | .name' | grep ${VMPREFIX} > ./vmlist
-			numvm=$(cat ./vmlist | wc -l)
-		done
-		sleep 10 ##置換##
-		echo "deleting disk"
-		parallel -a tmposdiskidlist "az disk delete --ids {} --yes"
-		sleep 10
-		# STATICMAC が true であればNIC、パブリックIPを再利用する
-		if [ "$STATICMAC" == "true" ] || [ "$STATICMAC" == "TRUE" ]; then
-			echo "keep existing nic and public ip"
-		else
-			echo "deleting nic"
-			seq 1 $MAXVM | parallel "az network nic delete -g $MyResourceGroup --name ${VMPREFIX}-{}VMNic"
-			az network nic delete -g $MyResourceGroup --name ${VMPREFIX}-pbsVMNic
-			az network nic delete -g $MyResourceGroup --name ${VMPREFIX}-loginVMNic
-			echo "deleting public ip"
-			seq 1 $MAXVM | parallel "az network public-ip delete -g $MyResourceGroup --name ${VMPREFIX}-{}PublicIP"
-			az network public-ip delete -g $MyResourceGroup --name ${VMPREFIX}-pbsPublicIP
-			az network public-ip delete -g $MyResourceGroup --name ${VMPREFIX}-loginPublicIP
-		fi
-		echo "detelting data disk"
-		az disk delete -g $MyResourceGroup --name ${VMPREFIX}-1-disk0 --yes
-		az disk delete -g $MyResourceGroup --name ${VMPREFIX}-pbs-disk0 --yes
-		echo "current running VMs: ${numvm}"
-		# ファイル削除
-		rm ./ipaddresslist
-		rm ./tmposdiskidlist
-		rm ./vmlist
-		rm ./config
-		rm ./fullpingpong.sh
-		rm ./pingponlist
-		rm ./nodelist
-		rm ./hostsfile
-		rm ./tmpcheckhostsfile
-		rm ./loginvmip
-		rm ./pbsvmip
-		rm ./md5*
-		rm ./openpbs*
-		rm ./pbsprivateip
-		rm ./loginpribateip
-	;;
-	deletevm )
-		# $2が必要
-		echo "PBSノードとしてのノード削除は行われないので、手動で削除すること"
-		disktmp=$(az vm show -g $MyResourceGroup --name ${VMPREFIX}-"${2}" --query storageProfile.osDisk.managedDisk.id -o tsv)
-		echo "deleting compute VMs"
-		az vm delete -g $MyResourceGroup --name ${VMPREFIX}-"${2}" --yes
-		# 削除すべき行番号を割り出し
-		tmpline=$(grep "${VMPREFIX}-${2}" -n ./vmlist | cut -d ":" -f 1)
-		echo "$tmpline"
-		echo "deliting line: $tmpline"
-		# vmlistから特定のVMを削除
-		sed -i -e "${tmpline}d" ./vmlist
-		echo "show new current vmlist"
-		cat ./vmlist
-		# nodelistから特定のVMを削除
-		sed -i -e "${tmpline}d" ./nodelist
-		echo "show new current nodelist"
-		cat ./nodelist
-		# ディスク削除
-		echo "deleting disk"
-		az disk delete --ids "${disktmp}" --yes
-		# STATICMAC が true であればNIC、パブリックIPを再利用する
-		if [ "$STATICMAC" == "true" ] || [ "$STATICMAC" == "TRUE" ]; then
-			echo "keep existing nic and public ip"
-		else
-			echo "deleting nic"
-			az network nic delete -g $MyResourceGroup --name ${VMPREFIX}-"${2}"VMNic
-			echo "deleting public ip"
-			az network public-ip delete -g $MyResourceGroup --name ${VMPREFIX}-"${2}"PublicIP
-		fi
-		# PBSジョブスケジューラから削除する
-		echo "deleting PBS node"
-		# deletenode.sh
-		rm ./deletenode.sh
-		echo "/opt/pbs/bin/qmgr -c "create delete ${VMPREFIX}-${2}"" >> deletenode.sh
-		# sed -i -e "s/-c /-c '/g" setuppbs.sh
-		# sed -i -e "s/$/\'/g" setuppbs.sh
-		echo "deletenode.sh: $(cat ./deletenode.sh)"
-		scp -o StrictHostKeyChecking=no -i "${SSHKEYDIR}" ./deletenode.sh $USERNAME@"${pbsvmip}":/home/$USERNAME/deletenode.sh
-		# SSH鍵登録：未実装
-		# ssh -o StrictHostKeyChecking=no -i ${SSHKEYDIR} $USERNAME@${pbsvmip} -t -t "sudo cp /root/.ssh/authorized_keys /root/.ssh/authorized_keys.old"
-		# ssh -o StrictHostKeyChecking=no -i ${SSHKEYDIR} $USERNAME@${pbsvmip} -t -t "sudo cp /home/$USERNAME/.ssh/authorized_keys /root/.ssh/authorized_keys"
-		# ジョブスケジューラセッティング
-		ssh -o StrictHostKeyChecking=no -i "${SSHKEYDIR}" root@"${pbsvmip}" -t -t "bash /home/$USERNAME/deletenode.sh"
-		# ホストファイル修正：未実装
-	;;
-	remount )
-		# mounting nfs server from compute node.
-		numvm=$(cat ./ipaddresslist | wc -l)
-		if [ -f ./ipaddresslist ]; then
-			# コマンド実行判断
-			vm1ip=$(az vm show -d -g $MyResourceGroup --name ${VMPREFIX}-1 --query publicIps -o tsv)
-			echo "${VMPREFIX}-1's IP: $vm1ip"
-			# コンピュートノードVM#1：マウント用プライベートIP 
-			mountip=$(az vm show -g $MyResourceGroup --name ${VMPREFIX}-1 -d --query privateIps -otsv)
-			# PBSノード：展開済みかチェック
-			pbsvmname=$(az vm show -d -g $MyResourceGroup --name ${VMPREFIX}-pbs --query name -o tsv)
-			# PBSノード：マウントプライベートIP
-			pbsmountip=$(az vm show -g $MyResourceGroup --name ${VMPREFIX}-pbs -d --query privateIps -otsv)
-			echo "current mounting status"
-			parallel -a ipaddresslist "ssh -o StrictHostKeyChecking=no -i ${SSHKEYDIR} -t -t $USERNAME@{} "df | grep '/mnt/resource/scratch'""
-			echo "${VMPREFIX}-1: $vm1ip"
-			ssh -o StrictHostKeyChecking=no -i "${SSHKEYDIR}" $USERNAME@"${vm1ip}" 'sudo showmount -e'
-			echo "${VMPREFIX}-2 to $MAXVM: mounting"
-			parallel -a ipaddresslist "ssh -o StrictHostKeyChecking=no -i ${SSHKEYDIR} -t -t $USERNAME@{} "sudo mkdir -p /mnt/resource/scratch""
-			parallel "$DEUBG" -a ipaddresslist "ssh -o StrictHostKeyChecking=no -i ${SSHKEYDIR} -t -t $USERNAME@{} "sudo chown $USERNAME:$USERNAME /mnt/resource/scratch""
-			parallel -a ipaddresslist "ssh -o StrictHostKeyChecking=no -i ${SSHKEYDIR} -t -t $USERNAME@{} "sudo mount -t nfs ${mountip}:/mnt/resource/scratch /mnt/resource/scratch""
-			# PBSノードが存在していれば、NFSマウントを実施
-			if [ -z "$pbsvmname" ]; then
-				parallel -a ipaddresslist "ssh -o StrictHostKeyChecking=no -i ${SSHKEYDIR} -t -t $USERNAME@{} "sudo mkdir -p /mnt/share""
-				parallel -a ipaddresslist "ssh -o StrictHostKeyChecking=no -i ${SSHKEYDIR} -t -t $USERNAME@{} "sudo chown $USERNAME:$USERNAME /mnt/share""
-				parallel -a ipaddresslist "ssh -o StrictHostKeyChecking=no -i ${SSHKEYDIR} -t -t $USERNAME@{} "sudo mount -t nfs ${pbsmountip}:/mnt/share""
-			fi
-		else
-			for count in $(seq 2 $MAXVM) ; do
-				az vm run-command invoke -g $MyResourceGroup --name ${VMPREFIX}-"${count}" --command-id RunShellScript --scripts "sudo mount -t nfs ${mountip}:/mnt/resource/scratch /mnt/resource/scratch" &
-			done
-			echo "sleep 180" && sleep 180
-			for count in $(seq 1 $MAXVM) ; do
-				if [ -n "$pbsvmname" ]; then
-					az vm run-command invoke -g $MyResourceGroup --name ${VMPREFIX}-"${count}" --command-id RunShellScript --scripts "sudo mount -t nfs ${pbsmountip}:/mnt/share /mnt/share" &
-					sleep 10
-				fi
-			done
-		fi
-	;;
-	pingpong )
-		# 初期設定：ファイル削除
-		if [ -f ./vmlist ]; then rm ./vmlist; fi
-		if [ -f ./ipaddresslist ]; then rm ./ipaddresslist; fi
-		if [ -f ./nodelist ]; then rm ./nodelist; fi
-		echo "creating vmlist and ipaddresslist"
-		az vm list-ip-addresses -g $MyResourceGroup --query "[].virtualMachine[].{Name:name, PrivateIPAddresses:network.privateIpAddresses[0], PublicIp:network.publicIpAddresses[0].ipAddress}" -o tsv > tmpfile
-		for count in $(seq 1 10); do
-			if [ -s ./tmpfile ]; then
-				break
-			else
-				az vm list-ip-addresses -g $MyResourceGroup --query "[].virtualMachine[].{Name:name, PrivateIPAddresses:network.privateIpAddresses[0], PublicIp:network.publicIpAddresses[0].ipAddress}" -o tsv > tmpfile
-				cat ./tmpfile
-				echo "getting list-ip-address: sleep 2" & sleep 2
-			fi
-		done
-		# 自然な順番でソートする
-		sort -V ./tmpfile > tmpfile2
-		# 取り出す前に、不必要な行は削除
-		grep -e "${VMPREFIX}-[1-99]" ./tmpfile2 > tmpfile3
-
-		# vmlist 取り出し：1列目
-		cut -f 1 ./tmpfile3 > vmlist
-		# nodelist 取り出し：2列目
-		echo "careating IP Address list"
-		cut -f 2 ./tmpfile3 > nodelist
-		# ipaddresslist 取り出し：3列目
-		echo "ipaddresslist file contents"
-		cut -f 3 ./tmpfile3 > ipaddresslist
-
-		# テンポラリファイル削除
-		rm ./tmpfile
-		rm ./tmpfile2
-		rm ./tmpfile3
-
-		# pingponglist ファイルチェック・削除
-		if [ -f ./pingponglist ]; then rm ./pingponglist; fi
-		# pingponglist 作成：全ノードの組み合わせ作成
-		for NODE in $(cat ./nodelist); do
-			for NODE2 in $(cat ./nodelist); do
-				echo "$NODE,$NODE2" >> pingponglist
-			done
-		done
-		# fullpingpongコマンドスクリプト作成
-		if [ -f ./fullpingpong.sh ]; then rm ./fullpingpong.sh; fi
-		cat <<'EOL' >> fullpingpong.sh
-#!/bin/bash
-checkosver=$(cat /etc/redhat-release | cut  -d " " -f 4)
-cp /home/$USER/* /mnt/resource/scratch/
-cd /mnt/resource/scratch/
-max=$(cat ./pingponglist | wc -l)
-count=1
-## TZ=JST-9 date
-echo "========================================================================"
-echo -n "$(TZ=JST-9 date '+%Y %b %d %a %H:%M %Z')" && echo " - pingpong #: $max, OS: ${checkosver}"
-echo "========================================================================"
-# run pingpong
-case $checkosver in
-	7.?.???? )
-		IMPI_VERSION=2018.4.274
-		for count in `seq 1 $max`; do
-			line=$(sed -n ${count}P ./pingponglist)
-			echo "############### ${line} ###############"; >> result
-			/opt/intel/impi/${IMPI_VERSION}/intel64/bin/mpirun -hosts $line -ppn 1 -n 2 -env I_MPI_FABRICS=shm:ofa /opt/intel/impi/${IMPI_VERSION}/bin64/IMB-MPI1 pingpong | grep -e ' 512 ' -e NODES -e usec; >> result
-		done
-	;;
-	8.?.???? )
-		IMPI_VERSION=2021.1.1
-		 source /opt/intel/oneapi/mpi/2021.1.1/env/vars.sh
-		for count in `seq 1 $max`; do
-			line=$(sed -n ${count}P ./pingponglist)
-			echo "############### ${line} ###############"; >> result
-			/opt/intel/oneapi/mpi/${IMPI_VERSION}/bin/mpiexec -hosts $line -ppn 1 -n 2 /opt/intel/oneapi/mpi/${IMPI_VERSION}/bin/IMB-MPI1 pingpong | grep -e ' 512 ' -e NODES -e usec; >> result
-		done
-	;;
-esac
-EOL
-# ヒアドキュメントのルール上改行不可
-		# SSHコンフィグファイルの再作成は必要ないため、削除
-		if [ ! -f  ./config ]; then
-			echo "no ssh config file in local directory!"
-			cat <<'EOL' >> config
-Host *
-StrictHostKeyChecking no
-UserKnownHostsFile=/dev/null
-EOL
-
-		fi
-		# コマンド実行方法判断
-		vm1ip=$(az vm show -d -g $MyResourceGroup --name ${VMPREFIX}-1 --query publicIps -o tsv)
-		checkssh=$(ssh -o StrictHostKeyChecking=no -i "${SSHKEYDIR}" $USERNAME@"${vm1ip}" "uname")
-		for count in $(seq 1 10); do
-			if [ -z "$checkssh" ]; then
-				checkssh=$(ssh -o StrictHostKeyChecking=no -i "${SSHKEYDIR}" $USERNAME@"${vm1ip}" "uname")
-				echo "accessing VM#1 by ssh...." && sleep 2
-			else
-				break
-			fi
-		done
-		if [ -n "$checkssh" ]; then
-			# SSHアクセス可能：SSHでダイレクトに実施（早い）
-			echo "running on direct access to all compute nodes"
-			# fullpingpong実行
-			echo "pingpong: show pingpong combination between nodes"
-			cat ./pingponglist
-			scp -o StrictHostKeyChecking=no -i "${SSHKEYDIR}" ./fullpingpong.sh $USERNAME@"${vm1ip}":/home/$USERNAME/
-			scp -o StrictHostKeyChecking=no -i "${SSHKEYDIR}" ./pingponglist $USERNAME@"${vm1ip}":/home/$USERNAME/
-			scp -o StrictHostKeyChecking=no -i "${SSHKEYDIR}" ./fullpingpong.sh $USERNAME@"${vm1ip}":/mnt/resource/scratch/
-			scp -o StrictHostKeyChecking=no -i "${SSHKEYDIR}" ./pingponglist $USERNAME@"${vm1ip}":/mnt/resource/scratch/
-			# SSH追加設定
-			cat ./ipaddresslist
-			echo "pingpong: copy passwordless settings"
-			seq 1 $MAXVM | parallel -a ipaddresslist "scp -o StrictHostKeyChecking=no -i ${SSHKEYDIR} ./config $USERNAME@{}:/home/$USERNAME/.ssh/config"
-			seq 1 $MAXVM | parallel -a ipaddresslist "ssh -o StrictHostKeyChecking=no -i ${SSHKEYDIR} $USERNAME@{} -t -t "chmod 600 /home/$USERNAME/.ssh/config""
-			# コマンド実行
-			echo "pingpong: running pingpong for all compute nodes"
-			ssh -o StrictHostKeyChecking=no -i "${SSHKEYDIR}" $USERNAME@"${vm1ip}" -t -t "rm /mnt/resource/scratch/result"
-			ssh -o StrictHostKeyChecking=no -i "${SSHKEYDIR}" $USERNAME@"${vm1ip}" -t -t "bash /mnt/resource/scratch/fullpingpong.sh > /mnt/resource/scratch/result"
-			echo "copying the result from vm1 to local"
-			scp -o StrictHostKeyChecking=no -i "${SSHKEYDIR}" $USERNAME@"${vm1ip}":/mnt/resource/scratch/result ./
-			ls -la ./*result*
-			cat ./result
-			echo "ローカルのresultファイルを確認"
-		else
-			# SSHアクセス不可能：ログインノード経由で設定
-			echo "running via loging node due to limited access to all compute nodes"
-			for count in $(seq 1 ${MAXVM}); do
-				loginprivateip=$(az vm show -g $MyResourceGroup --name ${VMPREFIX}-login -d --query privateIps -o tsv)
-				vm1privateip=$(az vm show -g $MyResourceGroup --name ${VMPREFIX}-1 -d --query privateIps -o tsv)
-				checkssh2=$(ssh -o StrictHostKeyChecking=no -o 'ConnectTimeout 30' -i "${SSHKEYDIR}" $USERNAME@"${loginvmip}" -t -t "uname")
-				for cnt in $(seq 1 10); do
-					if [ -n "$checkssh2" ]; then
-						break
-					else
-						echo "sleep 10" && sleep 1
-					fi
-				done
-				if [ -z "$checkssh2" ]; then
-					echo "error!: you can not access by ssh the login node!"
-					exit 1
-				fi
-				# ファイル転送: local to login node
-				echo "ローカル: ssh: ホストファイル転送 transfer login node"
-				scp -o StrictHostKeyChecking=no -i "${SSHKEYDIR}" ./fullpingpong.sh $USERNAME@"${loginvmip}":/home/$USERNAME/
-				scp -o StrictHostKeyChecking=no -i "${SSHKEYDIR}" ./pingponglist $USERNAME@"${loginvmip}":/home/$USERNAME/
-				scp -o StrictHostKeyChecking=no -i "${SSHKEYDIR}" ./fullpingpong.sh $USERNAME@"${loginvmip}":/mnt/resource/scratch/
-				scp -o StrictHostKeyChecking=no -i "${SSHKEYDIR}" ./pingponglist $USERNAME@"${loginvmip}":/mnt/resource/scratch/
-				# ファイル転送: login node to VM#1
-				ssh -o StrictHostKeyChecking=no -i "${SSHKEYDIR}" $USERNAME@"${loginvmip}" -t -t "scp -o StrictHostKeyChecking=no -i ${SSHKEYDIR} ./fullpingpong.sh $USERNAME${vm1privateip}:/home/$USERNAME/"
-				ssh -o StrictHostKeyChecking=no -i "${SSHKEYDIR}" $USERNAME@"${loginvmip}" -t -t "scp -o StrictHostKeyChecking=no -i ${SSHKEYDIR} ./pingponglist $USERNAME@${vm1privateip}:/home/$USERNAME/"
-				ssh -o StrictHostKeyChecking=no -i "${SSHKEYDIR}" $USERNAME@"${loginvmip}" -t -t "scp -o StrictHostKeyChecking=no -i ${SSHKEYDIR} ./fullpingpong.sh $USERNAME@${vm1privateip}:/mnt/resource/scratch/"
-				ssh -o StrictHostKeyChecking=no -i "${SSHKEYDIR}" $USERNAME@"${loginvmip}" -t -t "scp -o StrictHostKeyChecking=no -i ${SSHKEYDIR} ./pingponglist $USERNAME@${vm1privateip}:/mnt/resource/scratch/"
-				# pingpongコマンド実行
-				echo "pingpong: running pingpong for all compute nodes"
-				ssh -o StrictHostKeyChecking=no -i "${SSHKEYDIR}" $USERNAME@"${loginvmip}" -t -t "ssh -o StrictHostKeyChecking=no -i ${SSHKEYDIR} $USERNAME@${vm1privateip} -t -t 'rm /mnt/resource/scratch/result'"
-				ssh -o StrictHostKeyChecking=no -i "${SSHKEYDIR}" $USERNAME@"${loginvmip}" -t -t "ssh -o StrictHostKeyChecking=no -i ${SSHKEYDIR} $USERNAME@${vm1privateip} -t -t "bash /mnt/resource/scratch/fullpingpong.sh > /mnt/resource/scratch/result""
-				ssh -o StrictHostKeyChecking=no -i "${SSHKEYDIR}" $USERNAME@"${loginvmip}" -t -t "scp -o StrictHostKeyChecking=no -i ${SSHKEYDIR} $USERNAME@${vm1privateip}:/mnt/resource/scratch/result /home/$USERNAME/"
-				# 多段の場合、ローカルにもダウンロードが必要
-				echo "copying the result from vm1 to local"
-				scp -o StrictHostKeyChecking=no -i "${SSHKEYDIR}" $USERNAME@"${vm1privateip}":/home/$USERNAME/ ./
-				ls -la ./*result*
-				cat ./result
-				echo "ローカルのresultファイルを確認"
-			done
-		fi
 	;;
 #### ==========================================================================
+#### ==========================================================================
 	# ログインノード、PBSノードを作成します。
 	addlogin )
 		# 既存ネットワークチェック
@@ -1612,7 +1063,7 @@ EOL
 		done
 		if [ -n "$checkssh" ]; then
 			# 重複していないかチェック
-			ssh -o StrictHostKeyChecking=no -i "${SSHKEYDIR}" $USERNAME@${pbsvmip} -t -t "sudo grep '/dev/sdc1' /etc/fstab" > checkfstabpbs
+			ssh -o StrictHostKeyChecking=no -i "${SSHKEYDIR}" $USERNAME@"${pbsvmip}" -t -t "sudo grep '/dev/sdc1' /etc/fstab" > checkfstabpbs
 			checkfstabpbs=$(cat checkfstabpbs | wc -l)
 			if [ $((checkfstabpbs)) -ge 2 ]; then 
 				echo "pbsnode: deleting dupulicated settings...."
@@ -1652,11 +1103,12 @@ EOL
 		echo "pbsnode: nfs server settings"
 		ssh -o StrictHostKeyChecking=no -i "${SSHKEYDIR}" $USERNAME@"${pbsvmip}" -t -t "sudo yum install --quiet -y nfs-utils epel-release"
 		# アフターインストール：epel-release
-		ssh -o StrictHostKeyChecking=no -i "${SSHKEYDIR}" $USERNAME@"${pbsvmip}" -t -t "sudo yum install --quiet -y htop"
+		ssh -o StrictHostKeyChecking=no -i "${SSHKEYDIR}" $USERNAME@"${pbsvmip}" -t -t "sudo yum install --quiet -y md5sum htop"
 		ssh -o StrictHostKeyChecking=no -i "${SSHKEYDIR}" $USERNAME@"${pbsvmip}" -t -t "echo '/mnt/share *(rw,no_root_squash,async)' | sudo tee /etc/exports"
 		ssh -o StrictHostKeyChecking=no -i "${SSHKEYDIR}" $USERNAME@"${pbsvmip}" -t -t "sudo systemctl start rpcbind && sudo systemctl start nfs-server"
 		ssh -o StrictHostKeyChecking=no -i "${SSHKEYDIR}" $USERNAME@"${pbsvmip}" -t -t "sudo systemctl enable rpcbind && sudo systemctl enable nfs-server"
 		ssh -o StrictHostKeyChecking=no -i "${SSHKEYDIR}" $USERNAME@"${pbsvmip}" -t -t "sudo showmount -e"
+
 		# コンピュートノード：NFSマウント設定
 		pbsmountip=$(az vm show -g $MyResourceGroup --name ${VMPREFIX}-pbs -d --query privateIps -otsv)
 		echo "pbsnode: mouting new directry on compute nodes: /mnt/share"
@@ -1664,11 +1116,8 @@ EOL
 		if [ ! -f ./ipaddresslist ]; then
 			# vmlist 作成
 			echo "ipaddresslist is nothing...creating ipaddresslist"
-			az vm list-ip-addresses -g $MyResourceGroup --query "[].virtualMachine[].{Name:name, PublicIp:network.publicIpAddresses[0].ipAddress}" -o tsv > tmpfile
-			# 自然番号順にソート
-			sort -V ./tmpfile > tmpfile2
+			getipaddresslist vmlist ipaddresslist
 			# ipaddresslist 作成
-			cut -f 2 ./tmpfile2 > ipaddresslist
 			echo "ipaddresslist file contents"
 			cat ./ipaddresslist
 		fi
@@ -1678,10 +1127,9 @@ EOL
 		for count in $(seq 1 $MAXVM); do
 			line=$(sed -n "${count}"P ./ipaddresslist)
 			echo "VM: ${VMPREFIX}-${count}'s mouning..."
-			ssh -o StrictHostKeyChecking=no -i "${SSHKEYDIR}" $USERNAME@"${count}" -t -t "df -h | grep ${pbsmountip}:"
+			ssh -o StrictHostKeyChecking=no -i "${SSHKEYDIR}" $USERNAME@"${line}" -t -t "df -h | grep ${pbsmountip}:"
 		done
-		# PBSノード：インストール準備
-		ssh -o StrictHostKeyChecking=no -i "${SSHKEYDIR}" $USERNAME@"${pbsvmip}" -t -t "sudo yum install --quiet -y md5sum"
+
 		# ローカル：openPBSバイナリダウンロード
 		# PBSノード：CentOS バージョンチェック
 		ssh -o StrictHostKeyChecking=no -i "${SSHKEYDIR}" $USERNAME@"${pbsvmip}" -t -t "cat /etc/redhat-release" > centosversion
@@ -2013,7 +1461,558 @@ EOL
 		# PBSノードでの実施なので ipaddresslist(外部IP) から nodelist(内部IP) に変更
 		ssh -o StrictHostKeyChecking=no -i "${SSHKEYDIR}" $USERNAME@"${pbsvmip}" -t -t "sed -i -e "s!./ipaddresslist!./nodelist!" /home/$USERNAME/checknfs.sh"
 	;;
-### ===========================================================================
+#### ==========================================================================
+#### ==========================================================================
+	start )
+		## PBSノード：OSディスクタイプ変更: Premium_LRS
+		azure_sku2="Premium_LRS"
+		# PBSノードの存在チェック
+		osdiskidpbs=$(az vm show -g $MyResourceGroup --name "${VMPREFIX}"-pbs --query storageProfile.osDisk.managedDisk.id -o tsv)
+		if [ -n "$osdiskidpbs" ]; then
+			az disk update --sku ${azure_sku2} --ids "${osdiskidpbs}" -o table
+			echo "starting PBS VM"
+			az vm start -g $MyResourceGroup --name "${VMPREFIX}"-pbs -o none &
+			# PBSノードが存在すればログインノードも存在する
+			echo "starting loging VM"
+			az vm start -g $MyResourceGroup --name "${VMPREFIX}"-login -o none &
+		else
+			# PBSノードのOSディスクが存在しなければPBSノードも存在しない
+			echo "no PBS node here!"
+		fi
+	
+		# VM1-N: OSディスクタイプ変更: Premium_LRS
+		azure_sku2="Premium_LRS"
+		if [ ! -f ./tmposdiskidlist ]; then rm ./tmposdiskidlist; fi
+		for count in $(seq 1 "$MAXVM") ; do
+			disktmp=$(az vm show -g $MyResourceGroup --name "${VMPREFIX}"-"${count}" --query storageProfile.osDisk.managedDisk.id -o tsv)
+			echo "$disktmp" >> tmposdiskidlist
+		done
+		echo "converting computing node OS disk"
+		parallel -a ./tmposdiskidlist "az disk update --sku ${azure_sku2} --ids {} -o none &"
+		sleep 10
+		echo "starting VM ${VMPREFIX}-1"
+		az vm start -g $MyResourceGroup --name "${VMPREFIX}"-1 -o none &
+		echo "starting VM ${VMPREFIX}:2-$MAXVM compute nodes"
+		seq 2 "$MAXVM" | parallel "az vm start -g $MyResourceGroup --name ${VMPREFIX}-{} -o none &"
+		echo "checking $MAXVM compute VM's status"
+		numvm=0
+		tmpnumvm="default"
+		while [ -n "$tmpnumvm" ]; do
+			tmpnumvm=$(az vm list -d -g $MyResourceGroup --query "[?powerState=='VM starting']" -o tsv)
+			echo "$tmpnumvm" | tr ' ' '\n' > ./tmpnumvm.txt
+			numvm=$(grep -c "starting" ./tmpnumvm.txt)
+			echo "current starting VMs: $numvm. All VMs are already running!"
+			sleep 5
+		done
+		rm ./tmpnumvm.txt
+		sleep 30
+
+		# ダイナミックの場合（デフォルト）、再度IPアドレスリストを作成しなおす
+		if [ ! -f ./ipaddresslist ]; then rm ./ipaddresslist; fi
+		echo "creating ipaddresslist"
+		getipaddresslist vmlist ipaddresslist
+		echo "show new ipaddresslist"
+		cat ./ipaddresslist
+
+		# check ssh connectivity
+		checksshconnection all
+		connection=$(cat ./checksshtmp | wc -l)
+		if [ $((connection)) -eq $((MAXVM)) ]; then 
+			echo "all node ssh avaiable"
+		else
+			echo "some of nodes are not ssh avaiable"
+		fi
+		rm ./checksshtmp
+
+		# VM1 $2 マウント
+		echo "vm1: nfs server @ ${VMPREFIX}-1"
+		mountdirectory vm1 
+
+		echo "end of starting up computing nodes"
+		# PBSノードがなければ終了
+		if [ -z "$osdiskidpbs" ]; then
+			echo "no PBS node here!"
+			exit 0
+		fi
+		# PBSノード：マウント設定
+		echo "pbsnode: nfs server @ ${VMPREFIX}-pbs"
+		mountdirectory pbs
+		echo "end of start command"
+	;;
+	startvm )
+		## PBSノード：OSディスクタイプ変更: Premium_LRS
+		azure_sku2="Premium_LRS"
+		# PBSノードの存在チェック
+		osdiskidpbs=$(az vm show -g $MyResourceGroup --name "${VMPREFIX}"-pbs --query storageProfile.osDisk.managedDisk.id -o tsv)
+		if [ -n "$osdiskidpbs" ]; then
+			az disk update --sku ${azure_sku2} --ids "${osdiskidpbs}" -o table
+			echo "starting PBS VM"
+			az vm start -g $MyResourceGroup --name "${VMPREFIX}"-pbs -o none &
+			# PBSノードが存在すればログインノードも存在する
+			echo "starting loging VM"
+			az vm start -g $MyResourceGroup --name "${VMPREFIX}"-login -o none &
+		else
+			# PBSノードのOSディスクが存在しなければPBSノードも存在しない
+			echo "no PBS node here!"
+		fi
+	
+		# VM1-N: OSディスクタイプ変更: Premium_LRS
+		azure_sku2="Premium_LRS"
+		disktmp=$(az vm show -g $MyResourceGroup --name "${VMPREFIX}"-"${2}" --query storageProfile.osDisk.managedDisk.id -o tsv)
+		echo "converting computing node OS disk"
+		az disk update --sku ${azure_sku2} --ids ${disktmp} -o none
+		echo "starting VM ${VMPREFIX}-1"
+		az vm start -g $MyResourceGroup --name "${VMPREFIX}"-1 -o none
+		echo "starting VM ${VMPREFIX}:2-$MAXVM compute nodes"
+		az vm start -g $MyResourceGroup --name ${VMPREFIX}-${2} -o none
+		echo "checking $MAXVM compute VM's status"
+		sleep 30
+
+		# ダイナミックの場合（デフォルト）、再度IPアドレスリストを作成しなおす
+		if [ ! -f ./ipaddresslist ]; then rm ./ipaddresslist; fi
+		echo "creating ipaddresslist"
+		getipaddresslist vmlist ipaddresslist
+		echo "show new vm ip"
+		sed -n "${2}"P ./ipaddresslist 
+
+		# VM1 $2 マウント
+		echo "${VMPREFIX}-${2}: mounting vm1 nfs server...."
+		mountdirectory vm1 
+
+		# PBSノードがなければ終了
+		if [ -z "$osdiskidpbs" ]; then
+			echo "no PBS node here!"
+			exit 0
+		fi
+		# PBSノード：マウント設定
+		echo "${VMPREFIX}-${2}: mounting nfs server...."
+		mountdirectory pbs
+		echo "end of start command"
+	;;
+	stop )
+		for count in $(seq 1 "$MAXVM") ; do
+			echo "stoping VM $count"
+			az vm deallocate -g $MyResourceGroup --name "${VMPREFIX}"-"${count}" &
+		done
+	;;
+	stop-all )
+		if [ -f ./tmposdiskidlist ]; then rm ./tmposdiskidlist; fi
+		for count in $(seq 1 "$MAXVM") ; do
+			disktmp=$(az vm show -g $MyResourceGroup --name "${VMPREFIX}"-"${count}" --query storageProfile.osDisk.managedDisk.id -o tsv)
+			echo "$disktmp" >> tmposdiskidlist
+		done
+		for count in $(seq 1 "$MAXVM") ; do
+			echo "stoping VM $count"
+			az vm deallocate -g $MyResourceGroup --name "${VMPREFIX}"-"${count}" &
+		done
+		echo "stoping PBS VM"
+		az vm deallocate -g $MyResourceGroup --name "${VMPREFIX}"-pbs &
+		echo "stoping login VM"
+		az vm deallocate -g $MyResourceGroup --name "${VMPREFIX}"-login &
+		# OSディスクタイプ変更: Standard_LRS
+		azure_sku1="Standard_LRS"
+		echo "converting computing node OS disk"
+		parallel -v -a ./tmposdiskidlist "az disk update --sku ${azure_sku1} --ids {}"
+		# Dataディスクタイプ変更: Standard_LRS
+		echo "converting PBS node data disk"
+		az vm show -g $MyResourceGroup --name "${VMPREFIX}"-pbs --query storageProfile.dataDisks[*].managedDisk -o tsv | awk -F" " '{print $2}' | xargs -I{} az disk update --sku ${azure_sku1} --ids {}
+		echo "converting compute node #1 data disk"
+		az vm show -g $MyResourceGroup --name "${VMPREFIX}"-1 --query storageProfile.dataDisks[*].managedDisk -o tsv | awk -F" " '{print $2}' | xargs -I{} az disk update --sku ${azure_sku1} --ids {}
+	;;
+	stopvm )
+		echo "コマンドシンタクス:VM#2を停止する場合 ./$CMDNAME stopvm 2"
+		echo "stoping VM $2"
+		az vm deallocate -g $MyResourceGroup --name "${VMPREFIX}"-"$2" &
+	;;
+	stopvms )
+		echo "コマンドシンタクス:VM#2,3,4を停止する場合 ./$CMDNAME stopvm 2 4"
+		echo "stoping VM $2 $3"
+		for count in $(seq "$2" "$3") ; do
+			echo "stoping VM $count"
+			az vm deallocate -g $MyResourceGroup --name "${VMPREFIX}"-"${count}" &
+		done
+	;;
+	list )
+		echo "listng running/stopped VM"
+		az vm list -g $MyResourceGroup -d -o table
+
+		echo "prep..."
+		getipaddresslist vmlist ipaddresslist
+		echo "nfs server vm status"
+		# vm1state=$(az vm show -d -g $MyResourceGroup --name ${VMPREFIX}-1 --query powerState)
+		vm1ip=$(az vm show -d -g $MyResourceGroup --name "${VMPREFIX}"-1 --query publicIps -o tsv)
+		pbsvmip=$(az vm show -d -g $MyResourceGroup --name "${VMPREFIX}"-pbs --query publicIps -o tsv)
+		# PBSノードのパブリックIPアドレスの判定
+		if [ -z "$pbsvmip" ]; then
+			echo "no PBS node here! checking only compute nodes."
+			# コンピュートノードのみのチェック
+			count=0
+			checkssh=$(ssh -o StrictHostKeyChecking=no -o 'ConnectTimeout 30' -i "${SSHKEYDIR}" -t $USERNAME@"${vm1ip}" "uname")
+			if [ -n "$checkssh" ]; then
+				echo "${VMPREFIX}-1: nfs server status"
+				ssh -o StrictHostKeyChecking=no -i "${SSHKEYDIR}" $USERNAME@"${vm1ip}" 'sudo showmount -e'
+				echo "nfs client mount status"
+					for count in $(seq 2 "$MAXVM"); do
+						line=$(sed -n "${count}"P ./ipaddresslist)
+						ssh -o StrictHostKeyChecking=no -i "${SSHKEYDIR}" -t -t $USERNAME@"${line}" "echo '########## host: ${VMPREFIX}-${count} ##########'"
+						ssh -o StrictHostKeyChecking=no -i "${SSHKEYDIR}" -t -t $USERNAME@"${line}" "df | grep '/mnt/'"
+					done
+				else
+					# SSHできないのでaz vm run-commandでの情報取得
+					echo "az vm run-command: nfs server status"
+					az vm run-command invoke -g $MyResourceGroup --name "${VMPREFIX}"-1 --command-id RunShellScript --scripts "sudo showmount -e"
+					echo "nfs client mount status:=======1-2 others: skiped======="
+					az vm run-command invoke -g $MyResourceGroup --name "${VMPREFIX}"-1 --command-id RunShellScript --scripts "df | grep /mnt/"
+					az vm run-command invoke -g $MyResourceGroup --name "${VMPREFIX}"-2 --command-id RunShellScript --scripts "df | grep /mnt/"
+			fi
+			# コンピュートノードVM#1のマウントだけ完了し、コマンド完了
+			echo "end of list command"
+			exit 0
+		fi
+		# PBSノード、コンピュートノードのNFSマウント確認
+		count=0
+		checkssh=$(ssh -o StrictHostKeyChecking=no -o 'ConnectTimeout 30' -i "${SSHKEYDIR}" -t $USERNAME@"${vm1ip}" "uname")
+		checkssh2=$(ssh -o StrictHostKeyChecking=no -o 'ConnectTimeout 30' -i "${SSHKEYDIR}" -t $USERNAME@"${pbsvmip}" "uname")
+		if [ -n "$checkssh" ] && [ -n "$checkssh2" ]; then
+			echo "${VMPREFIX}-pbs: nfs server status"
+			ssh -o StrictHostKeyChecking=no -i "${SSHKEYDIR}" $USERNAME@"${pbsvmip}" 'sudo showmount -e'
+			echo "${VMPREFIX}-1: nfs server status"
+			ssh -o StrictHostKeyChecking=no -i "${SSHKEYDIR}" $USERNAME@"${vm1ip}" 'sudo showmount -e'
+			echo "nfs client mount status"
+			for count in $(seq 2 "$MAXVM"); do
+				line=$(sed -n "${count}"P ./ipaddresslist)
+				ssh -o StrictHostKeyChecking=no -i "${SSHKEYDIR}" -t -t $USERNAME@"${line}" "echo '########## host: ${VMPREFIX}-${count} ##########'"
+				ssh -o StrictHostKeyChecking=no -i "${SSHKEYDIR}" -t -t $USERNAME@"${line}" "df | grep '/mnt/'"
+			done
+		else
+			echo "az vm run-command: nfs server status"
+			az vm run-command invoke -g $MyResourceGroup --name "${VMPREFIX}"-pbs --command-id RunShellScript --scripts "sudo showmount -e"
+			az vm run-command invoke -g $MyResourceGroup --name "${VMPREFIX}"-1 --command-id RunShellScript --scripts "sudo showmount -e"
+			echo "nfs client mount status:=======VM 1-2'status. other VMs are skiped======="
+			az vm run-command invoke -g $MyResourceGroup --name "${VMPREFIX}"-1 --command-id RunShellScript --scripts "df | grep /mnt/"
+			az vm run-command invoke -g $MyResourceGroup --name "${VMPREFIX}"-2 --command-id RunShellScript --scripts "df | grep /mnt/"
+		fi
+	;;
+	delete )
+		if [ -f ./tmposdiskidlist ]; then rm ./tmposdiskidlist; fi
+		for count in $(seq 1 "$MAXVM") ; do
+			disktmp=$(az vm show -g $MyResourceGroup --name "${VMPREFIX}"-"${count}" --query storageProfile.osDisk.managedDisk.id -o tsv)
+			echo "$disktmp" >> tmposdiskidlist
+		done
+		echo "deleting compute VMs"
+		seq 1 "$MAXVM" | parallel "az vm delete -g $MyResourceGroup --name ${VMPREFIX}-{} --yes &"
+		numvm=$(cat ./vmlist | wc -l)
+		checkpbs=$(grep pbs ./vmlist)
+		if [ -n "$checkpbs" ]; then
+			# no pbs
+			while [ $((numvm)) -gt 2 ]; do
+				echo "sleep 30" && sleep 30
+				echo "current running VMs: $numvm"
+				az vm list -g $MyResourceGroup | jq '.[] | .name' | grep "${VMPREFIX}" > ./vmlist
+				numvm=$(cat ./vmlist | wc -l)
+			done
+		echo "deleted all compute VMs"
+		else
+			# pbs node existing
+			while [ $((numvm)) -gt 0 ]; do
+				echo "sleep 30" && sleep 30
+				echo "current running VMs: $numvm"
+				az vm list -g $MyResourceGroup | jq '.[] | .name' | grep "${VMPREFIX}" > ./vmlist
+				numvm=$(cat ./vmlist | wc -l)
+			done
+		fi
+		echo "deleted all compute VMs. PBS and login node are existing"
+		echo "deleting disk"
+		parallel -a tmposdiskidlist "az disk delete --ids {} --yes"
+		sleep 10
+		# STATICMAC が true であればNIC、パブリックIPを再利用する
+		if [ "$STATICMAC" == "true" ] || [ "$STATICMAC" == "TRUE" ]; then
+			echo "keep existing nic and public ip"
+		else
+			echo "deleting nic"
+			seq 1 "$MAXVM" | parallel "az network nic delete -g $MyResourceGroup --name ${VMPREFIX}-{}VMNic"
+			echo "deleting public ip"
+			seq 1 "$MAXVM" | parallel "az network public-ip delete -g $MyResourceGroup --name ${VMPREFIX}-{}PublicIP"
+		fi
+		echo "detele data disk"
+		az disk delete -g $MyResourceGroup --name "${VMPREFIX}"-1-disk0 --yes
+		echo "current running VMs: ${numvm}"
+		# ファイル削除
+		rm ./ipaddresslist
+		rm ./tmposdiskidlist
+		rm ./vmlist
+		rm ./nodelist
+	;;
+	delete-all )
+		if [ -f ./tmposdiskidlist ]; then
+			rm ./tmposdiskidlist
+		fi
+		for count in $(seq 1 "$MAXVM") ; do
+			disktmp=$(az vm show -g $MyResourceGroup --name "${VMPREFIX}"-"${count}" --query storageProfile.osDisk.managedDisk.id -o tsv)
+			echo "$disktmp" >> tmposdiskidlist
+		done
+		disktmp=$(az vm show -g $MyResourceGroup --name "${VMPREFIX}"-pbs --query storageProfile.osDisk.managedDisk.id -o tsv)
+		echo "$disktmp" >> tmposdiskidlist
+		disktmp=$(az vm show -g $MyResourceGroup --name "${VMPREFIX}"-login --query storageProfile.osDisk.managedDisk.id -o tsv)
+		echo "$disktmp" >> tmposdiskidlist
+		echo "deleting compute VMs"
+		seq 1 "$MAXVM" | parallel "az vm delete -g $MyResourceGroup --name ${VMPREFIX}-{} --yes &"
+		echo "deleting pbs node"
+		az vm delete -g $MyResourceGroup --name "${VMPREFIX}"-pbs --yes &
+		echo "deleting login node"
+		az vm delete -g $MyResourceGroup --name "${VMPREFIX}"-login --yes &
+		# vmlistがある前提
+		if [ ! -f "./vmlist" ]; then 
+			numvm=$(cat ./vmlist | wc -l)
+		else
+			numvm=$((MAXVM))
+		fi
+		# VM削除までの待ち時間
+		while [ $((numvm)) -gt 0 ]; do
+			echo "sleep 30" && sleep 30
+			echo "current running VMs: $numvm"
+			az vm list -g $MyResourceGroup | jq '.[] | .name' | grep "${VMPREFIX}" > ./vmlist
+			numvm=$(cat ./vmlist | wc -l)
+		done
+		sleep 10 ##置換##
+		echo "deleting disk"
+		parallel -a tmposdiskidlist "az disk delete --ids {} --yes"
+		sleep 10
+		# STATICMAC が true であればNIC、パブリックIPを再利用する
+		if [ "$STATICMAC" == "true" ] || [ "$STATICMAC" == "TRUE" ]; then
+			echo "keep existing nic and public ip"
+		else
+			echo "deleting nic"
+			seq 1 "$MAXVM" | parallel "az network nic delete -g $MyResourceGroup --name ${VMPREFIX}-{}VMNic"
+			az network nic delete -g $MyResourceGroup --name "${VMPREFIX}"-pbsVMNic
+			az network nic delete -g $MyResourceGroup --name "${VMPREFIX}"-loginVMNic
+			echo "deleting public ip"
+			seq 1 "$MAXVM" | parallel "az network public-ip delete -g $MyResourceGroup --name ${VMPREFIX}-{}PublicIP"
+			az network public-ip delete -g $MyResourceGroup --name "${VMPREFIX}"-pbsPublicIP
+			az network public-ip delete -g $MyResourceGroup --name "${VMPREFIX}"-loginPublicIP
+		fi
+		echo "detelting data disk"
+		az disk delete -g $MyResourceGroup --name "${VMPREFIX}"-1-disk0 --yes
+		az disk delete -g $MyResourceGroup --name "${VMPREFIX}"-pbs-disk0 --yes
+		echo "current running VMs: ${numvm}"
+		# ファイル削除
+		rm ./ipaddresslist
+		rm ./tmposdiskidlist
+		rm ./vmlist
+		rm ./config
+		rm ./fullpingpong.sh
+		rm ./pingponlist
+		rm ./nodelist
+		rm ./hostsfile
+		rm ./tmpcheckhostsfile
+		rm ./loginvmip
+		rm ./pbsvmip
+		rm ./md5*
+		rm ./openpbs*
+		rm ./pbsprivateip
+		rm ./loginpribateip
+	;;
+	deletevm )
+		# $2が必要
+		echo "PBSノードとしてのノード削除は行われないので、手動で削除すること"
+		disktmp=$(az vm show -g $MyResourceGroup --name "${VMPREFIX}"-"${2}" --query storageProfile.osDisk.managedDisk.id -o tsv)
+		echo "deleting compute VMs"
+		az vm delete -g $MyResourceGroup --name "${VMPREFIX}"-"${2}" --yes
+		# 削除すべき行番号を割り出し
+		tmpline=$(grep "${VMPREFIX}-${2}" -n ./vmlist | cut -d ":" -f 1)
+		echo "$tmpline"
+		echo "deliting line: $tmpline"
+		# vmlistから特定のVMを削除
+		sed -i -e "${tmpline}d" ./vmlist
+		echo "show new current vmlist"
+		cat ./vmlist
+		# nodelistから特定のVMを削除
+		sed -i -e "${tmpline}d" ./nodelist
+		echo "show new current nodelist"
+		cat ./nodelist
+		# ディスク削除
+		echo "deleting disk"
+		az disk delete --ids "${disktmp}" --yes
+		# STATICMAC が true であればNIC、パブリックIPを再利用する
+		if [ "$STATICMAC" == "true" ] || [ "$STATICMAC" == "TRUE" ]; then
+			echo "keep existing nic and public ip"
+		else
+			echo "deleting nic"
+			az network nic delete -g $MyResourceGroup --name "${VMPREFIX}"-"${2}"VMNic
+			echo "deleting public ip"
+			az network public-ip delete -g $MyResourceGroup --name "${VMPREFIX}"-"${2}"PublicIP
+		fi
+		# PBSジョブスケジューラから削除する
+		echo "deleting PBS node"
+		# deletenode.sh
+		rm ./deletenode.sh
+		echo "/opt/pbs/bin/qmgr -c "create delete "${VMPREFIX}"-${2}"" >> deletenode.sh
+		# sed -i -e "s/-c /-c '/g" setuppbs.sh
+		# sed -i -e "s/$/\'/g" setuppbs.sh
+		echo "deletenode.sh: $(cat ./deletenode.sh)"
+		scp -o StrictHostKeyChecking=no -i "${SSHKEYDIR}" ./deletenode.sh $USERNAME@"${pbsvmip}":/home/$USERNAME/deletenode.sh
+		# SSH鍵登録：未実装
+		# ssh -o StrictHostKeyChecking=no -i ${SSHKEYDIR} $USERNAME@${pbsvmip} -t -t "sudo cp /root/.ssh/authorized_keys /root/.ssh/authorized_keys.old"
+		# ssh -o StrictHostKeyChecking=no -i ${SSHKEYDIR} $USERNAME@${pbsvmip} -t -t "sudo cp /home/$USERNAME/.ssh/authorized_keys /root/.ssh/authorized_keys"
+		# ジョブスケジューラセッティング
+		ssh -o StrictHostKeyChecking=no -i "${SSHKEYDIR}" root@"${pbsvmip}" -t -t "bash /home/$USERNAME/deletenode.sh"
+		# ホストファイル修正：未実装
+	;;
+	remount )
+		# mounting nfs server from compute node.
+		if [ -f ./ipaddresslist ]; then rm ./ipaddresslist; fi
+		getipaddresslist vmlist ipaddresslist
+
+		echo "vm1 remounting..."
+		mountdirectory vm1
+
+		# PBSノード：展開済みかチェック
+		echo "pbs...."
+		pbsvmname=$(az vm show -d -g $MyResourceGroup --name "${VMPREFIX}"-pbs --query name -o tsv)
+		if [ -n "$pbsvmname" ]; then
+			echo "pbs remounting...."
+			mountdirectory pbs
+		fi
+	;;
+	pingpong )
+		# 初期設定：ファイル削除
+		if [ -f ./vmlist ]; then rm ./vmlist; fi
+		if [ -f ./ipaddresslist ]; then rm ./ipaddresslist; fi
+		if [ -f ./nodelist ]; then rm ./nodelist; fi
+		echo "creating vmlist and ipaddresslist and nodelist"
+		getipaddresslist vmlist ipaddresslist nodelist
+		
+		# pingponglist ファイルチェック・削除
+		if [ -f ./pingponglist ]; then rm ./pingponglist; fi
+		# pingponglist 作成：全ノードの組み合わせ作成
+		for NODE in $(cat ./nodelist); do
+			for NODE2 in $(cat ./nodelist); do
+				echo "$NODE,$NODE2" >> pingponglist
+			done
+		done
+		# fullpingpongコマンドスクリプト作成
+		if [ -f ./fullpingpong.sh ]; then rm ./fullpingpong.sh; fi
+		cat <<'EOL' >> fullpingpong.sh
+#!/bin/bash
+checkosver=$(cat /etc/redhat-release | cut  -d " " -f 4)
+cp /home/$USER/* /mnt/resource/scratch/
+cd /mnt/resource/scratch/
+max=$(cat ./pingponglist | wc -l)
+count=1
+## TZ=JST-9 date
+echo "========================================================================"
+echo -n "$(TZ=JST-9 date '+%Y %b %d %a %H:%M %Z')" && echo " - pingpong #: $max, OS: ${checkosver}"
+echo "========================================================================"
+# run pingpong
+case $checkosver in
+	7.?.???? )
+		IMPI_VERSION=2018.4.274
+		for count in `seq 1 $max`; do
+			line=$(sed -n ${count}P ./pingponglist)
+			echo "############### ${line} ###############"; >> result
+			/opt/intel/impi/${IMPI_VERSION}/intel64/bin/mpirun -hosts $line -ppn 1 -n 2 -env I_MPI_FABRICS=shm:ofa /opt/intel/impi/${IMPI_VERSION}/bin64/IMB-MPI1 pingpong | grep -e ' 512 ' -e NODES -e usec; >> result
+		done
+	;;
+	8.?.???? )
+		IMPI_VERSION=2021.1.1
+		 source /opt/intel/oneapi/mpi/2021.1.1/env/vars.sh
+		for count in `seq 1 $max`; do
+			line=$(sed -n ${count}P ./pingponglist)
+			echo "############### ${line} ###############"; >> result
+			/opt/intel/oneapi/mpi/${IMPI_VERSION}/bin/mpiexec -hosts $line -ppn 1 -n 2 /opt/intel/oneapi/mpi/${IMPI_VERSION}/bin/IMB-MPI1 pingpong | grep -e ' 512 ' -e NODES -e usec; >> result
+		done
+	;;
+esac
+EOL
+# ヒアドキュメントのルール上改行不可
+		# SSHコンフィグファイルの再作成は必要ないため、削除
+		if [ ! -f  ./config ]; then
+			echo "no ssh config file in local directory!"
+			cat <<'EOL' >> config
+Host *
+StrictHostKeyChecking no
+UserKnownHostsFile=/dev/null
+EOL
+
+		fi
+		# コマンド実行方法判断
+		vm1ip=$(az vm show -d -g $MyResourceGroup --name "${VMPREFIX}"-1 --query publicIps -o tsv)
+		checkssh=$(ssh -o StrictHostKeyChecking=no -i "${SSHKEYDIR}" $USERNAME@"${vm1ip}" "uname")
+		for count in $(seq 1 10); do
+			if [ -z "$checkssh" ]; then
+				checkssh=$(ssh -o StrictHostKeyChecking=no -i "${SSHKEYDIR}" $USERNAME@"${vm1ip}" "uname")
+				echo "accessing VM#1 by ssh...." && sleep 2
+			else
+				break
+			fi
+		done
+		if [ -n "$checkssh" ]; then
+			# SSHアクセス可能：SSHでダイレクトに実施（早い）
+			echo "running on direct access to all compute nodes"
+			# fullpingpong実行
+			echo "pingpong: show pingpong combination between nodes"
+			cat ./pingponglist
+			scp -o StrictHostKeyChecking=no -i "${SSHKEYDIR}" ./fullpingpong.sh $USERNAME@"${vm1ip}":/home/$USERNAME/
+			scp -o StrictHostKeyChecking=no -i "${SSHKEYDIR}" ./pingponglist $USERNAME@"${vm1ip}":/home/$USERNAME/
+			scp -o StrictHostKeyChecking=no -i "${SSHKEYDIR}" ./fullpingpong.sh $USERNAME@"${vm1ip}":/mnt/resource/scratch/
+			scp -o StrictHostKeyChecking=no -i "${SSHKEYDIR}" ./pingponglist $USERNAME@"${vm1ip}":/mnt/resource/scratch/
+			# SSH追加設定
+			cat ./ipaddresslist
+			echo "pingpong: copy passwordless settings"
+			seq 1 "$MAXVM" | parallel -a ipaddresslist "scp -o StrictHostKeyChecking=no -i ${SSHKEYDIR} ./config $USERNAME@{}:/home/$USERNAME/.ssh/config"
+			seq 1 "$MAXVM" | parallel -a ipaddresslist "ssh -o StrictHostKeyChecking=no -i ${SSHKEYDIR} $USERNAME@{} -t -t "chmod 600 /home/$USERNAME/.ssh/config""
+			# コマンド実行
+			echo "pingpong: running pingpong for all compute nodes"
+			ssh -o StrictHostKeyChecking=no -i "${SSHKEYDIR}" $USERNAME@"${vm1ip}" -t -t "rm /mnt/resource/scratch/result"
+			ssh -o StrictHostKeyChecking=no -i "${SSHKEYDIR}" $USERNAME@"${vm1ip}" -t -t "bash /mnt/resource/scratch/fullpingpong.sh > /mnt/resource/scratch/result"
+			echo "copying the result from vm1 to local"
+			scp -o StrictHostKeyChecking=no -i "${SSHKEYDIR}" $USERNAME@"${vm1ip}":/mnt/resource/scratch/result ./
+			ls -la ./*result*
+			cat ./result
+			echo "ローカルのresultファイルを確認"
+		else
+			# SSHアクセス不可能：ログインノード経由で設定
+			echo "running via loging node due to limited access to all compute nodes"
+			for count in $(seq 1 "${MAXVM}"); do
+				loginprivateip=$(az vm show -g $MyResourceGroup --name "${VMPREFIX}"-login -d --query privateIps -o tsv)
+				vm1privateip=$(az vm show -g $MyResourceGroup --name "${VMPREFIX}"-1 -d --query privateIps -o tsv)
+				checkssh2=$(ssh -o StrictHostKeyChecking=no -o 'ConnectTimeout 30' -i "${SSHKEYDIR}" $USERNAME@"${loginvmip}" -t -t "uname")
+				for cnt in $(seq 1 10); do
+					if [ -n "$checkssh2" ]; then
+						break
+					else
+						echo "sleep 10" && sleep 1
+					fi
+				done
+				if [ -z "$checkssh2" ]; then
+					echo "error!: you can not access by ssh the login node!"
+					exit 1
+				fi
+				# ファイル転送: local to login node
+				echo "ローカル: ssh: ホストファイル転送 transfer login node"
+				scp -o StrictHostKeyChecking=no -i "${SSHKEYDIR}" ./fullpingpong.sh $USERNAME@"${loginvmip}":/home/$USERNAME/
+				scp -o StrictHostKeyChecking=no -i "${SSHKEYDIR}" ./pingponglist $USERNAME@"${loginvmip}":/home/$USERNAME/
+				scp -o StrictHostKeyChecking=no -i "${SSHKEYDIR}" ./fullpingpong.sh $USERNAME@"${loginvmip}":/mnt/resource/scratch/
+				scp -o StrictHostKeyChecking=no -i "${SSHKEYDIR}" ./pingponglist $USERNAME@"${loginvmip}":/mnt/resource/scratch/
+				# ファイル転送: login node to VM#1
+				ssh -o StrictHostKeyChecking=no -i "${SSHKEYDIR}" $USERNAME@"${loginvmip}" -t -t "scp -o StrictHostKeyChecking=no -i ${SSHKEYDIR} ./fullpingpong.sh $USERNAME${vm1privateip}:/home/$USERNAME/"
+				ssh -o StrictHostKeyChecking=no -i "${SSHKEYDIR}" $USERNAME@"${loginvmip}" -t -t "scp -o StrictHostKeyChecking=no -i ${SSHKEYDIR} ./pingponglist $USERNAME@${vm1privateip}:/home/$USERNAME/"
+				ssh -o StrictHostKeyChecking=no -i "${SSHKEYDIR}" $USERNAME@"${loginvmip}" -t -t "scp -o StrictHostKeyChecking=no -i ${SSHKEYDIR} ./fullpingpong.sh $USERNAME@${vm1privateip}:/mnt/resource/scratch/"
+				ssh -o StrictHostKeyChecking=no -i "${SSHKEYDIR}" $USERNAME@"${loginvmip}" -t -t "scp -o StrictHostKeyChecking=no -i ${SSHKEYDIR} ./pingponglist $USERNAME@${vm1privateip}:/mnt/resource/scratch/"
+				# pingpongコマンド実行
+				echo "pingpong: running pingpong for all compute nodes"
+				ssh -o StrictHostKeyChecking=no -i "${SSHKEYDIR}" $USERNAME@"${loginvmip}" -t -t "ssh -o StrictHostKeyChecking=no -i ${SSHKEYDIR} $USERNAME@${vm1privateip} -t -t 'rm /mnt/resource/scratch/result'"
+				ssh -o StrictHostKeyChecking=no -i "${SSHKEYDIR}" $USERNAME@"${loginvmip}" -t -t "ssh -o StrictHostKeyChecking=no -i ${SSHKEYDIR} $USERNAME@${vm1privateip} -t -t "bash /mnt/resource/scratch/fullpingpong.sh > /mnt/resource/scratch/result""
+				ssh -o StrictHostKeyChecking=no -i "${SSHKEYDIR}" $USERNAME@"${loginvmip}" -t -t "scp -o StrictHostKeyChecking=no -i ${SSHKEYDIR} $USERNAME@${vm1privateip}:/mnt/resource/scratch/result /home/$USERNAME/"
+				# 多段の場合、ローカルにもダウンロードが必要
+				echo "copying the result from vm1 to local"
+				scp -o StrictHostKeyChecking=no -i "${SSHKEYDIR}" $USERNAME@"${vm1privateip}":/home/$USERNAME/ ./
+				ls -la ./*result*
+				cat ./result
+				echo "ローカルのresultファイルを確認"
+			done
+		fi
+	;;
 	updatensg )
 		# NSGアップデート：既存の実行ホストからのアクセスを修正
 		echo "current host global ip address: $LIMITEDIP"
@@ -2053,7 +2052,6 @@ EOL
 	;;
 	ssh )
 		# SSHアクセスする
-
 		case ${2} in
 			login )
 				loginvmip=$(az vm show -d -g $MyResourceGroup --name "${VMPREFIX}"-pbs --query publicIps -o tsv)
@@ -2162,4 +2160,5 @@ EOL
 	;;
 esac
 
-echo "$CMDNAME: end of vm hpc environment create script"
+
+echo "$CMDNAME: end of vm hpc environment create script"
\ No newline at end of file
